{% extends "base.html" %}

{% block content %}
<div class="container mt-4">
    <div class="row mb-4">
        <div class="col-md-8">
            <div class="d-flex justify-content-between align-items-start">
                <div>
                    <h2>Game {{ game.round_number }} - {{ game.team1 }} vs {{ game.team2 }}
                        {% if not game.is_resolved %}
                            <span class="badge bg-warning text-dark">Awaiting Previous Results</span>
                        {% endif %}
                    </h2>
                    <p class="mb-0">Tournament: {{ game.tournament_name }} | Stage: {{ game.stage_id }}</p>
                </div>
                <div class="d-flex gap-2">
                    <button id="callTdBtn" class="btn btn-warning" title="Call Tournament Director">
                        <i class="bi bi-flag me-1"></i> Call TD
                    </button>
                    <button id="emergencyBtn" class="btn btn-danger" title="Emergency - Summon Help Immediately">
                        <i class="bi bi-exclamation-triangle me-1"></i> Emergency
                    </button>
                    <button id="downloadScorecardBtn" class="btn btn-outline-primary">
                        <i class="bi bi-download me-1"></i> Download Scorecard
                    </button>
                    <button id="protestBtn" class="btn btn-outline-danger" data-bs-toggle="modal" data-bs-target="#protestModal">
                        <i class="bi bi-flag me-1"></i> File Protest
                    </button>
                </div>
            </div>
            
            {% if not game.is_resolved %}
                <div class="alert alert-info">
                    <h5><i class="bi bi-hourglass-split"></i> Waiting on Previous Matches</h5>
                    <p>This game depends on the results of previous matches:</p>
                    <ul class="mb-0">
                        {% if game.pending_teams.team1 %}
                            {% set pending = game.pending_teams.team1 %}
                            <li>
                                <strong>Team 1</strong> will be the winner of:
                                <div class="ms-3 mt-1">
                                    <div>Match {{ pending.match }} (Stage {{ pending.stage }}, Round {{ pending.round }})</div>
                                    <div class="ms-2">
                                        {{ pending.team1 }} <span class="text-muted">vs</span> {{ pending.team2 }}
                                    </div>
                                    {% if pending.is_tie %}
                                        <div class="text-warning"><i class="bi bi-exclamation-triangle"></i> This match ended in a tie</div>
                                    {% endif %}
                                    <div class="text-muted small">Reference: {{ pending.ref }}</div>
                                </div>
                            </li>
                        {% endif %}
                        
                        {% if game.pending_teams.team2 %}
                            {% set pending = game.pending_teams.team2 %}
                            <li class="mt-2">
                                <strong>Team 2</strong> will be the winner of:
                                <div class="ms-3 mt-1">
                                    <div>Match {{ pending.match }} (Stage {{ pending.stage }}, Round {{ pending.round }})</div>
                                    <div class="ms-2">
                                        {{ pending.team1 }} <span class="text-muted">vs</span> {{ pending.team2 }}
                                    </div>
                                    {% if pending.is_tie %}
                                        <div class="text-warning"><i class="bi bi-exclamation-triangle"></i> This match ended in a tie</div>
                                    {% endif %}
                                    <div class="text-muted small">Reference: {{ pending.ref }}</div>
                                </div>
                            </li>
                        {% endif %}
                    </ul>
                </div>
            {% endif %}
        </div>
        <div class="col-md-4 text-end">
            <!-- <button id="submitGameBtn" class="btn btn-primary" disabled>Submit Game</button>
            <button id="saveProgressBtn" class="btn btn-secondary ms-2">Save Progress</button> -->
            <!-- <button id="downloadScorecardBtn" class="btn btn-outline-info ms-2" title="Download Scorecard JSON">
                <i class="bi bi-download"></i>
            </button> -->
        </div>
    </div>

    <!-- Score Display -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <div class="card-body">
                    <div class="row text-center">
                        <div class="col-md-5">
                            <h3>{{ game.team1 }}</h3>
                            <div class="d-flex justify-content-center gap-4">
                                <div>
                                    <div class="small text-muted">Tossups</div>
                                    <div id="team1TossupScore" class="h4">0</div>
                                </div>
                                <div>
                                    <div class="small text-muted">Bonuses</div>
                                    <div id="team1BonusScore" class="h4">0</div>
                                </div>
                                <div>
                                    <div class="small text-muted">Total</div>
                                    <div id="team1Score" class="h3">0</div>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-2 text-center d-flex align-items-center justify-content-center">
                            <div class="h2">vs</div>
                        </div>
                        <div class="col-md-5">
                            <h3>{{ game.team2 }}</h3>
                            <div class="d-flex justify-content-center gap-4">
                                <div>
                                    <div class="small text-muted">Tossups</div>
                                    <div id="team2TossupScore" class="h4">0</div>
                                </div>
                                <div>
                                    <div class="small text-muted">Bonuses</div>
                                    <div id="team2BonusScore" class="h4">0</div>
                                </div>
                                <div>
                                    <div class="small text-muted">Total</div>
                                    <div id="team2Score" class="h3">0</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="card-footer">
                    <button type="button" class="btn btn-sm btn-outline-primary" data-bs-toggle="modal" data-bs-target="#addPlayerModal">
                        <i class="bi bi-plus-circle"></i> Add Player to Team
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Player Selection -->
    <div class="card mb-4">
        <div class="card-header">
            <h4>Player Selection</h4>
            <p class="mb-0">Select which players are active for this cycle:</p>
        </div>
        <div class="card-body">
            <div class="row">
                <div class="col-md-6">
                    <h5>
                        {{ team1_display_name }}
                        {% if pending_team1_info %}
                            <span class="badge bg-warning" title="This team will be determined by a previous game">TBD</span>
                            <div class="small text-muted mt-1">
                                <i class="fas fa-info-circle"></i> Waiting for {{ pending_team1_info.reference }}
                            </div>
                        {% endif %}
                    </h5>
                    <div id="team1Players" class="mb-3">
                        {% if pending_team1_info %}
                            <div class="alert alert-info">
                                <i class="fas fa-clock"></i> Players will be available after the previous game is completed.
                                <div class="mt-2">
                                    <strong>Game {{ pending_team1_info.reference }}</strong><br>
                                    {{ pending_team1_info.team1 }} vs {{ pending_team1_info.team2 }}
                                </div>
                            </div>
                        {% elif players_team1 %}
                            <div class="player-list">
                                {% for player in players_team1 %}
                                {% set player_id = player.id|default(loop.index) %}
                                <div class="form-check form-check-inline mb-2 me-3">
                                    <input type="checkbox" 
                                           class="form-check-input player-checkbox me-1" 
                                           id="player1_{{ player_id }}" 
                                           data-team="1" 
                                           data-player-id="{{ player_id }}"
                                           data-name="{{ player.name|e }}" 
                                           {% if player.active is not defined or player.active %}checked{% endif %} />
                                    <label class="form-check-label" for="player1_{{ player_id }}">
                                        {{ player.name }}
                                    </label>
                                </div>
                                {% endfor %}
                            </div>
                        {% else %}
                            <div class="alert alert-warning">
                                <i class="fas fa-exclamation-triangle"></i> No players found for this team.
                            </div>
                            <script>
                                // <![CDATA[
                                (function() {
                                    'use strict';
                                    console.warn('No players found for team1 ({{ game.team1|tojson|safe }})');
                                })();
                                // ]]>
                            </script>
                        {% endif %}
                    </div>
                    <script>
                        document.addEventListener('DOMContentLoaded', function() {
                            const team1Name = JSON.parse('{{ game.team1|tojson|safe }}');
                            const team1Players = JSON.parse('{{ players_team1|tojson|safe }}');
                            console.log('Team 1 (' + team1Name + ') players:', team1Players);
                        });
                    </script>
                </div>
                <div class="col-md-6">
                    <h5>
                        {{ team2_display_name }}
                        {% if pending_team2_info %}
                            <span class="badge bg-warning" title="This team will be determined by a previous game">TBD</span>
                            <div class="small text-muted mt-1">
                                <i class="fas fa-info-circle"></i> Waiting for {{ pending_team2_info.reference }}
                            </div>
                        {% endif %}
                    </h5>
                    <div id="team2Players" class="mb-3">
                        {% if pending_team2_info %}
                            <div class="alert alert-info">
                                <i class="fas fa-clock"></i> Players will be available after the previous game is completed.
                                <div class="mt-2">
                                    <strong>Game {{ pending_team2_info.reference }}</strong><br>
                                    {{ pending_team2_info.team1 }} vs {{ pending_team2_info.team2 }}
                                </div>
                            </div>
                        {% elif players_team2 %}
                            <div class="player-list">
                                {% for player in players_team2 %}
                                {% set player_id = player.id|default(loop.index + 1000) %}
                                <div class="form-check form-check-inline mb-2 me-3">
                                    <input type="checkbox" 
                                           class="form-check-input player-checkbox me-1" 
                                           id="player2_{{ player_id }}" 
                                           data-team="2" 
                                           data-player-id="{{ player_id }}"
                                           data-name="{{ player.name|e }}" 
                                           {% if player.active is not defined or player.active %}checked{% endif %} />
                                    <label class="form-check-label" for="player2_{{ player_id }}">
                                        {{ player.name }}
                                    </label>
                                </div>
                                {% endfor %}
                            </div>
                        {% else %}
                            <div class="alert alert-warning">
                                <i class="fas fa-exclamation-triangle"></i> No players found for this team.
                            </div>
                            <script>
                                // <![CDATA[
                                (function() {
                                    'use strict';
                                    console.warn('No players found for team2 ({{ game.team2|tojson|safe }})');
                                })();
                                // ]]>
                            </script>
                        {% endif %}
                    </div>
                    <script>
                        document.addEventListener('DOMContentLoaded', function() {
                            const team2Name = JSON.parse('{{ game.team2|tojson|safe }}');
                            const team2Players = JSON.parse('{{ players_team2|tojson|safe }}');
                            console.log('Team 2 (' + team2Name + ') players:', team2Players);
                        });
                    </script>
                </div>
            </div>
        </div>
    </div>

    <!-- Add Player Modal -->
    <div class="modal fade" id="addPlayerModal" tabindex="-1" aria-labelledby="addPlayerModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="addPlayerModalLabel">Add Player to Team</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <form id="addPlayerForm">
                        <div class="mb-3">
                            <label for="teamSelect" class="form-label">Team</label>
                            <select class="form-select" id="teamSelect" required>
                                <option value="1">{{ team1_display_name }}</option>
                                <option value="2">{{ team2_display_name }}</option>
                            </select>
                        </div>
                        <div class="mb-3">
                            <label for="playerName" class="form-label">Player Name</label>
                            <input type="text" class="form-control" id="playerName" required 
                                   placeholder="Enter player's full name">
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="confirmAddPlayer">Add Player</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Game Interface -->
    <div class="card mb-4">
        <div class="card-header">
            <div class="d-flex justify-content-between align-items-center mb-2">
                <h4 class="mb-0">Cycle <span id="currentCycleDisplay">1</span> of 20</h4>
                <div class="text-muted" id="progressPercentage">5% Complete</div>
            </div>
            <div class="progress" style="height: 20px;">
                <div class="progress-bar" id="progressBar" role="progressbar" style="width: 5%;">
                    <span class="visually-hidden">5% Complete</span>
                </div>
            </div>
        </div>
        
        <div class="card-body">
            <!-- Tossup Section -->
            <div id="tossupSection">
                <h5 class="mb-3">Tossup Question</h5>
                <div id="tossupQuestion" class="mb-4 p-3 bg-light rounded position-relative">
                    <div class="question-text user-select-none"></div>
                    <div class="text-muted small mt-2">Click on a word where the answer was given to score</div>
                    <!-- Completed Question Overlay -->
                    <div id="completedQuestionOverlay" class="position-absolute top-0 start-0 w-100 h-100 d-flex align-items-center justify-content-center" style="background: rgba(255,255,255,0.8); border-radius: 0.25rem; z-index: 5;">
                        <div class="text-center p-3">
                            <div class="mb-2">Tossup already scored</div>
                            <button type="button" class="btn btn-sm btn-outline-secondary" onclick="window.gameState && window.gameState.clearCurrentCycle();">
                                Clear to edit
                            </button>
                        </div>
                    </div>
                </div>
                    <!-- Navigation Bar - Bottom Right -->
                    <div class="d-flex justify-content-end mt-3">
                        <div id="navigationBar" class="btn-group" role="group" aria-label="Cycle Navigation">
                            <button type="button" class="btn btn-outline-secondary" id="prevCycleBtn" 
                                onclick="window.gameState && window.gameState.prevCycle(); return false;"
                                title="Previous Cycle">
                                <i class="bi bi-arrow-left"></i>
                            </button>
                            <button type="button" class="btn btn-outline-primary" id="nextCycleBtn"
                                onclick="window.gameState && window.gameState.skipToNextCycle(); return false;"
                                title="Skip to Next (No Points)">
                                <i class="bi bi-arrow-right"></i>
                            </button>
                            <button type="button" class="btn btn-outline-danger" id="throwOutTossupBtn" 
                                onclick="window.gameState && window.gameState.throwOutTossup(); return false;"
                                title="Throw Out Tossup">
                                <i class="bi bi-trash"></i>
                            </button>
                            <button type="button" class="btn btn-outline-warning" id="clearCycleBtn" 
                                onclick="window.gameState && window.gameState.clearCurrentCycle(); return false;"
                                title="Clear Current Cycle">
                                <i class="bi bi-x-circle"></i>
                            </button>
                        </div>
                    </div>
                    
                    <div class="alert alert-info mt-3">
                        <i class="bi bi-info-circle"></i> Click on any word in the question to open the scoring modal and select a player.
                    </div>
                </div>
            </div>
            
            <!-- Bonus Section -->
            <div id="bonusSection" style="display: none;">
                <h5 class="mb-3">Bonus Questions</h5>
                <div id="bonusQuestions" class="mb-4">
                    <!-- Bonus questions will be inserted here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Scorecard at bottom of content (initially hidden) -->
    <!-- <div class="text-center mt-3 mb-3" id="showScorecardBtn">
        <button type="button" class="btn btn-outline-primary" id="toggleScorecardBtn">
            <i class="bi bi-table me-1"></i> Show Scorecard
        </button>
    </div>
     -->
    <div class="mt-2 mb-5" id="scorecardSection" style="display: none;">
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5 class="mb-0">Scorecard</h5>
                <button type="button" class="btn-close" id="closeScorecard"></button>
            </div>
            <div class="card-body p-0">
                <div id="scorecardPreview" class="table-responsive">
                    <div class="text-center text-muted py-3">
                        <i class="bi bi-table"></i> Scorecard will appear here as the game progresses
                    </div>
                </div>
            </div>
        </div>
    </div>
    

    <!-- Scoring Modal -->
    <div class="modal fade" id="scoringModal" tabindex="-1" aria-labelledby="scoringModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="scoringModalLabel">Score Tossup</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div id="clickedWordDisplay" class="mb-3"></div>
                    <div id="progressDisplay" class="mb-3"></div>
                    
                    <!-- Player Selection Area -->
                    <div id="playerSelectionArea" class="mb-4">
                        <h6>Select a player:</h6>
                        <div class="row">
                            <div class="col-md-6">
                                <div class="card mb-3">
                                    <div class="card-header bg-primary text-white">
                                        {{ game.team1 }}
                                    </div>
                                    <div class="card-body">
                                        {% for player in players_team1 %}
                                            <button type="button" class="btn btn-outline-primary w-100 mb-2 player-selection-btn"
                                                    onclick="quizbowl.handlePlayerSelection(1, '{{ loop.index0 }}', event)">
                                                {{ player.name }}
                                            </button>
                                        {% endfor %}
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-6">
                                <div class="card">
                                    <div class="card-header bg-danger text-white">
                                        {{ game.team2 }}
                                    </div>
                                    <div class="card-body">
                                        {% for player in players_team2 %}
                                            <button type="button" class="btn btn-outline-danger w-100 mb-2 player-selection-btn"
                                                    onclick="quizbowl.handlePlayerSelection(2, '{{ loop.index0 }}', event)">
                                                {{ player.name }}
                                            </button>
                                        {% endfor %}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Answer Buttons (initially hidden) -->
                    <div id="answerButtonsArea" style="display: none;">
                        <h6>Mark answer for <span id="selectedPlayerName" class="fw-bold"></span>:</h6>
                        <div class="d-grid gap-2">
                            <button type="button" class="btn btn-success mb-2" id="markCorrectBtn"
                                    onclick="quizbowl.markAnswer(true)">
                                <i class="fas fa-check"></i> Correct Answer
                            </button>
                            <button type="button" class="btn btn-danger mb-2" id="markIncorrectBtn"
                                    onclick="quizbowl.markAnswer(false)">
                                <i class="fas fa-times"></i> Incorrect Answer
                            </button>
                        </div>
                    </div>
                    
                    <!-- Score Selection (initially hidden) -->
                    <div id="scoreSelectionArea" style="display: none;">
                        <!-- Will be populated dynamically -->
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden form for submission -->
    <form id="submitForm" method="POST" action="{{ url_for('reader.submit_game', game_id=game.id) }}" style="display: none;">
        <input type="hidden" name="scorecard" id="scorecardInput">
    </form>

    <!-- Protest Modal -->
    <div class="modal fade" id="protestModal" tabindex="-1" aria-labelledby="protestModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="protestModalLabel">File a Protest</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <form id="protestForm">
                        <input type="hidden" id="protestGameId" value="{{ game['id'] }}">
                        <input type="hidden" id="protestTournamentId" value="{{ game['tournament_id'] }}">
                        <div class="mb-3">
                            <label for="protestCycle" class="form-label">Cycle Number</label>
                            <input type="number" class="form-control" id="protestCycle" min="1" value="1" required>
                        </div>
                        <div class="mb-3">
                            <label for="protestMessage" class="form-label">Protest Details</label>
                            <textarea class="form-control" id="protestMessage" rows="4" required 
                                      placeholder="Please describe the issue with this cycle in detail..."></textarea>
                        </div>
                        <div class="alert alert-info">
                            <i class="bi bi-info-circle-fill me-1"></i>
                            Protests will be reviewed by the tournament director. Please be as specific as possible.
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-danger" id="submitProtestBtn">
                        <i class="bi bi-flag-fill me-1"></i> Submit Protest
                    </button>
                </div>
            </div>
        </div>
    </div>
{% endblock %}

{% block styles %}
{{ super() }}
<style>
    /* Navigation Bar Styles */
    #navigationBar {
        transition: all 0.3s ease;
    }
    #navigationBar .btn {
        width: 40px;
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0;
        border-radius: 50%;
        margin: 0 2px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    #navigationBar .btn i {
        font-size: 1.2rem;
    }
    #navigationBar .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    #navigationBar .btn:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.15);
    }
</style>
{% endblock %}

{% block scripts %}
{{ super() }}
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Toggle scorecard visibility
        const toggleScorecardBtn = document.getElementById('toggleScorecardBtn');
        const scorecardSection = document.getElementById('scorecardSection');
        
        if (toggleScorecardBtn && scorecardSection) {
            toggleScorecardBtn.addEventListener('click', function() {
                const isHidden = scorecardSection.style.display === 'none';
                scorecardSection.style.display = isHidden ? 'block' : 'none';
                this.innerHTML = isHidden 
                    ? '<i class="bi bi-eye-slash me-1"></i> Hide Scorecard'
                    : '<i class="bi bi-table me-1"></i> Show Scorecard';
                
                // If showing the scorecard, update it
                if (isHidden && window.quizbowl) {
                    window.quizbowl.updateScorecard();
                }
            });
            
            // Close button in scorecard header
            const closeScorecardBtn = document.getElementById('closeScorecard');
            if (closeScorecardBtn) {
                closeScorecardBtn.addEventListener('click', function() {
                    scorecardSection.style.display = 'none';
                    toggleScorecardBtn.innerHTML = '<i class="bi bi-table me-1"></i> Show Scorecard';
                });
            }
        }
    });
</script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
<!-- Server data as JSON -->
<script id="server-data" type="application/json">
{
    "game": {{ game|tojson|safe }},
    "playersTeam1": {{ players_team1|tojson|safe }},
    "playersTeam2": {{ players_team2|tojson|safe }},
    "questions": {{ questions|tojson|safe }},
    "bonuses": {{ bonuses|tojson|safe }},
    "scorecard": {{ scorecard|tojson|safe if scorecard else '[]' }},
    "tournament": {{ tournament|tojson|safe }}
}
</script>

<script>
// Game state and configuration
(function() {
    'use strict';
    
    console.log('Initializing game...');
    
    // Get server data
    const serverDataElement = document.getElementById('server-data');
    if (!serverDataElement) {
        console.error('Server data element not found!');
        return;
    }
    
    const serverData = JSON.parse(serverDataElement.textContent);
    
    // Debug: Log the raw server data
    console.log('Raw server data:', serverData);
    
    // Game state object
    const gameState = {
        // Game state
        currentCycle: 0,
        totalCycles: 20,
        scorecard: {
            cycles: []
        },
        
        // Track players for each team
        playersTeam1: (serverData.playersTeam1 || []).map(p => ({
            id: p.id || p.player_id || `temp_${Math.random().toString(36).substr(2, 9)}`,
            name: p.name || p.player_name || 'Unknown Player',
            team: 1
        })),
        playersTeam2: (serverData.playersTeam2 || []).map(p => ({
            id: p.id || p.player_id || `temp_${Math.random().toString(36).substr(2, 9)}`,
            name: p.name || p.player_name || 'Unknown Player',
            team: 2
        })),
        
        // Track active players for each team
        activePlayers: {
            team1: [],
            team2: []
        },

        selectedPlayer: null,
        scoringModal: null,
        
        // Format question text to make words clickable
        // This function is no longer used since we're creating clickable words in loadQuestion
        formatQuestionText: function(text) {
            console.log('formatQuestionText called but not used - using loadQuestion for word formatting');
            if (!text) {
                console.error('Empty text provided to formatQuestionText');
                return '';
            }
            // Just return the text as is, we'll handle the formatting in loadQuestion
            return text;
        },

        // Initialize the scoring modal
        initScoringModal: function() {
            console.log('Initializing scoring modal');
            const modalElement = document.getElementById('scoringModal');
            console.log('Modal element:', modalElement);
            
            if (!modalElement) {
                console.error('Scoring modal element not found');
                return;
            }
            
            this.scoringModal = new bootstrap.Modal(modalElement);
            console.log('Bootstrap modal initialized');
            
            // We'll handle clicks in the loadQuestion function instead
            console.log('Modal initialization complete');
            
            // Populate modal with players
            this.updateModalPlayers();
        },
        
        // Update modal player lists
        updateModalPlayers: function() {
            const team1Container = document.getElementById('modalTeam1Players');
            const team2Container = document.getElementById('modalTeam2Players');
            
            // Create player buttons for team 1
            team1Container.innerHTML = this.serverData.playersTeam1 ? this.serverData.playersTeam1.map((player, index) => {
                const playerName = this.getPlayerName(player);
                return `
                    <button class="btn btn-outline-primary mb-2 w-100 player-select-btn" 
                            data-team="1" data-player="${index}" data-player-id="${player.id || index}">
                        ${playerName}
                    </button>
                `;
            }).join('') : '';
            
            // Create player buttons for team 2
            team2Container.innerHTML = this.serverData.playersTeam2 ? this.serverData.playersTeam2.map((player, index) => {
                const playerName = this.getPlayerName(player);
                return `
                    <button class="btn btn-outline-danger mb-2 w-100 player-select-btn" 
                            data-team="2" data-player="${index}" data-player-id="${player.id || (1000 + index)}">
                        ${playerName}
                    </button>
                `;
            }).join('') : '';
            
            // Add click handlers to player buttons
            document.querySelectorAll('.player-select-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const team = e.target.dataset.team;
                    const playerIndex = parseInt(e.target.dataset.player);
                    this.handlePlayerSelection(team, playerIndex, e);
                });
            });
        },
        
        // Open scoring modal
        openScoringModal: function(element, word, index) {
            // Store the current word index and element for scoring
            this.clickedWordElement = element;
            this.selectedWord = word;
            this.currentWordIndex = index;
            
            // Debug power mark detection
            const question = this.questions[this.currentCycle];
            if (question) {
                console.log('=== POWER MARK DEBUG ===');
                console.log('Question text:', question.question_text);
                console.log('Clicked word index:', index);
                console.log('Clicked word:', word);
                
                // Get the plain text version of the question (without HTML tags)
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = question.question_text;
                const plainText = tempDiv.textContent || tempDiv.innerText || '';
                
                const powerMarkIndex = plainText.indexOf('(*)')
                console.log('Power mark position in plain text:', powerMarkIndex);
                
                if (powerMarkIndex !== -1) {
                    // Get all words in the plain text before the power mark
                    const textBeforePower = plainText.substring(0, powerMarkIndex);
                    const wordsBeforePower = textBeforePower.split(/\s+/).filter(w => w.trim() !== '');
                    
                    // Get the current word's position in the plain text
                    const allWords = plainText.split(/\s+/).filter(w => w.trim() !== '');
                    const currentWord = allWords[index];
                    
                    console.log('Plain text words before power mark:', wordsBeforePower);
                    console.log('Current word in plain text:', currentWord);
                    console.log('Current word index vs words before power:', index, wordsBeforePower.length);
                    console.log('Should be power (true=15, false=10):', index < wordsBeforePower.length);
                } else {
                    console.log('No power mark found in question');
                }
                console.log('========================');
            }
            
            // Initialize the current cycle if it doesn't exist
            if (!this.scorecard.cycles[this.currentCycle]) {
                console.log('[DEBUG] Initializing new cycle in openScoringModal');
                this.scorecard.cycles[this.currentCycle] = {
                    tossup: { 
                        points: null, 
                        team: null, 
                        player: null, 
                        playerIndex: null,
                        team1Answered: false,
                        team2Answered: false
                    },
                    bonus: { team1: 0, team2: 0, parts: [null, null, null] },
                    scores: [[], [], [], []]
                };
            }
            
            // Reset modal state
            document.getElementById('playerSelectionArea').style.display = 'block';
            document.getElementById('answerButtonsArea').style.display = 'none';
            document.getElementById('scoreSelectionArea').style.display = 'none';
            
            // Update the modal title with the clicked word
            const displayElement = document.getElementById('clickedWordDisplay');
            if (displayElement) {
                displayElement.textContent = `Scoring for: ${word}`;
            }
            
            // Update progress display
            const progress = Math.round((this.validCycles / this.totalCycles) * 100);
            const progressElement = document.getElementById('progressDisplay');
            if (progressElement) {
                const cycleDisplay = this.isTiebreaker ? 
                    `Tiebreaker ${this.currentCycle - 20 + 1}` : 
                    `Cycle ${this.currentCycle + 1} of ${this.totalCycles}`;
                progressElement.textContent = `Progress: ${progress}% (${cycleDisplay})`;
            }
            
            // Initialize the modal if not already done
            if (!this.scoringModal) {
                const modalElement = document.getElementById('scoringModal');
                if (modalElement) {
                    this.scoringModal = new bootstrap.Modal(modalElement);
                    
                    // Set up modal event listeners
                    modalElement.addEventListener('hidden.bs.modal', () => {
                        // Reset modal state when hidden
                        document.getElementById('playerSelectionArea').style.display = 'block';
                        document.getElementById('answerButtonsArea').style.display = 'none';
                        document.getElementById('scoreSelectionArea').style.display = 'none';
                        this.selectedPlayer = null;
                        
                        // Reset any selected player buttons
                        document.querySelectorAll('.player-selection-btn').forEach(btn => {
                            btn.classList.remove('active');
                        });
                    });
                }
            }
            
            // Show the modal
            if (this.scoringModal) {
                this.scoringModal.show();
                console.log('Modal shown successfully');
                
                // Reset the modal state
                document.getElementById('playerSelectionArea').style.display = 'block';
                document.getElementById('answerButtonsArea').style.display = 'none';
                document.querySelectorAll('.player-selection-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                this.selectedPlayer = null;
            } else {
                console.error('Could not initialize modal');
                return;
            }
            
            // Store the clicked element for later use if needed
            this.clickedElement = element;
            this.selectedWord = word;
            this.selectedPlayer = null;
            this.currentWordIndex = index;
            
            // Highlight the clicked word
            document.querySelectorAll('.clickable-word').forEach(wordEl => {
                wordEl.style.fontWeight = '';
            });
            element.style.fontWeight = 'bold';
        },
        
        // Handle player selection in modal
        handlePlayerSelection: function(team, playerIndex, event) {
            try {
                console.log('handlePlayerSelection called with:', { team, playerIndex, event });
                
                // Prevent default behavior if event is provided
                if (event) {
                    event.preventDefault();
                    event.stopPropagation();
                }
                
                // Convert team to number
                team = parseInt(team);
                playerIndex = parseInt(playerIndex);
                
                // Get current cycle data
                const currentCycleData = this.scorecard.cycles[this.currentCycle] || {};
                const tossup = currentCycleData.tossup || {};
                
                // Check if team has already answered in this cycle
                const teamAnswered = team === 1 ? tossup.team1Answered : tossup.team2Answered;
                if (teamAnswered) {
                    console.log(`[DEBUG] Team ${team} has already answered this tossup`);
                    return;
                }
                
                // If the other team has already answered correctly, don't allow an answer
                if (this.currentAnswerer?.isCorrect) {
                    console.log('[DEBUG] Question already answered correctly by other team');
                    return;
                }
                
                // Get player name from the button that was clicked or from server data
                let playerName = '';
                if (event && event.target) {
                    playerName = event.target.textContent.trim();
                } else {
                    const teamPlayers = team === 1 ? this.serverData.playersTeam1 : this.serverData.playersTeam2;
                    playerName = teamPlayers && teamPlayers[playerIndex] ? teamPlayers[playerIndex] : `Player ${playerIndex + 1}`;
                }
                
                console.log(`[DEBUG] Selected player: ${playerName} from team ${team}`);
                
                // Set current answerer and selectedPlayer (for backward compatibility)
                this.currentAnswerer = {
                    team: team,
                    playerIndex: playerIndex,
                    playerName: playerName,
                    isCorrect: false,
                    cycleIndex: this.currentCycle  // Track which cycle this answer is for
                };
                
                this.selectedPlayer = {
                    team: team,
                    playerIndex: playerIndex,
                    name: playerName
                };
                
                console.log(`[DEBUG] Set currentAnswerer for cycle ${this.currentCycle}:`, this.currentAnswerer);
                
                // Initialize tossup object in current cycle if it doesn't exist
                if (!this.scorecard.cycles[this.currentCycle]) {
                    this.scorecard.cycles[this.currentCycle] = {
                        tossup: { 
                            points: null, 
                            team: null, 
                            player: null, 
                            playerIndex: null,
                            team1Answered: false,
                            team2Answered: false
                        },
                        bonus: { team1: 0, team2: 0, parts: [null, null, null] },
                        scores: [[], [], [], []]
                    };
                }
                
                const currentCycle = this.scorecard.cycles[this.currentCycle];
                if (!currentCycle) {
                    console.error('Current cycle not found');
                    return;
                }
                
                // Initialize tossup object if it doesn't exist
                if (!currentCycle.tossup) {
                    currentCycle.tossup = { points: null, team: null, player: null, playerIndex: null };
                }
                
                // Update tossup with player info
                currentCycle.tossup.team = team;
                currentCycle.tossup.player = playerName;
                currentCycle.tossup.playerIndex = playerIndex;
                
                // Initialize scores array if needed
                if (!currentCycle.scores) {
                    currentCycle.scores = [[], [], [], []];  // team1Tossup, team1Bonus, team2Tossup, team2Bonus
                }
                
                // Update active state for player buttons
                const playerButtons = document.querySelectorAll('.player-select-btn');
                if (playerButtons && playerButtons.length > 0) {
                    playerButtons.forEach(btn => {
                        btn.classList.remove('active');
                    });
                    
                    if (event && event.currentTarget) {
                        event.currentTarget.classList.add('active');
                    }
                }
                
                // Show score selection and hide player selection
                const playerSelection = document.getElementById('playerSelectionArea');
                const scoreSelection = document.getElementById('scoreSelectionArea');
                const answerButtons = document.getElementById('answerButtonsArea');
                
                if (playerSelection) playerSelection.style.display = 'none';
                if (scoreSelection) scoreSelection.style.display = 'block';
                if (answerButtons) {
                    answerButtons.style.display = 'block';
                    // Enable the answer buttons
                    const markCorrectBtn = document.getElementById('markCorrectBtn');
                    const markIncorrectBtn = document.getElementById('markIncorrectBtn');
                    if (markCorrectBtn) markCorrectBtn.disabled = false;
                    if (markIncorrectBtn) markIncorrectBtn.disabled = false;
                }
                
                // Set focus to the correct button for keyboard navigation
                const markCorrectBtn = document.getElementById('markCorrectBtn');
                if (markCorrectBtn) {
                    markCorrectBtn.focus();
                }
                
                console.log('Player selection completed successfully');
                
            } catch (error) {
                console.error('Error in handlePlayerSelection:', error);
            }
        },
        
        // Update active players for the current cycle based on checkboxes
        // This function captures the current state of checkboxes and updates the active players
        updateActivePlayers: function() {
            try {
                const currentCycle = this.getCurrentCycle();
                
                // Track which players are now active
                const activeTeam1Players = [];
                const activeTeam2Players = [];
                
                // Process team 1 players
                document.querySelectorAll('#team1Players .player-checkbox').forEach(checkbox => {
                    const playerId = parseInt(checkbox.dataset.playerId, 10);
                    const playerName = checkbox.dataset.name || `Player ${playerId}`;
                    const isActive = checkbox.checked;
                    
                    if (playerId) {
                        // Update player's active state in the cycle
                        const existingPlayer = currentCycle.team1Players.find(p => p.id === playerId);
                        if (existingPlayer) {
                            existingPlayer.active = isActive;
                        } else {
                            currentCycle.team1Players.push({
                                id: playerId,
                                name: playerName,
                                active: isActive
                            });
                        }
                        
                        if (isActive) {
                            activeTeam1Players.push(playerId);
                        }
                    }
                });
                
                // Process team 2 players
                document.querySelectorAll('#team2Players .player-checkbox').forEach(checkbox => {
                    const playerId = parseInt(checkbox.dataset.playerId, 10);
                    const playerName = checkbox.dataset.name || `Player ${playerId}`;
                    const isActive = checkbox.checked;
                    
                    if (playerId) {
                        // Update player's active state in the cycle
                        const existingPlayer = currentCycle.team2Players.find(p => p.id === playerId);
                        if (existingPlayer) {
                            existingPlayer.active = isActive;
                        } else {
                            currentCycle.team2Players.push({
                                id: playerId,
                                name: playerName,
                                active: isActive
                            });
                        }
                        
                        if (isActive) {
                            activeTeam2Players.push(playerId);
                        }
                    }
                });
                
                // Update activePlayers for this cycle
                currentCycle.activePlayers = {
                    team1: activeTeam1Players,
                    team2: activeTeam2Players
                };
                
                // Ensure scores arrays are properly sized
                if (!currentCycle.team1Scores || currentCycle.team1Scores.length !== currentCycle.team1Players.length) {
                    currentCycle.team1Scores = Array(currentCycle.team1Players.length).fill(0);
                }
                if (!currentCycle.team2Scores || currentCycle.team2Scores.length !== currentCycle.team2Players.length) {
                    currentCycle.team2Scores = Array(currentCycle.team2Players.length).fill(0);
                }
                
                console.log('Updated active players for cycle:', {
                    cycle: this.currentCycle,
                    activeTeam1: activeTeam1Players,
                    activeTeam2: activeTeam2Players,
                    allTeam1Players: currentCycle.team1Players,
                    allTeam2Players: currentCycle.team2Players
                });
                
                // Save state
                this.saveState();
                
                return true;
            } catch (error) {
                console.error('Error updating active players:', error);
                return false;
            }
        },
        
        // Get active players for the current cycle
        getActivePlayersForCycle: function(cycleIndex, teamNum) {
            try {
                const cycle = this.scorecard.cycles[cycleIndex];
                if (!cycle) return [];
                
                const teamKey = teamNum === 1 ? 'team1Players' : 'team2Players';
                return cycle[teamKey] || [];
            } catch (error) {
                console.error('Error getting active players for cycle:', error);
                return [];
            }
        },
        
        // Get the current cycle, initializing if needed
        getCurrentCycle: function() {
            if (!this.scorecard.cycles[this.currentCycle]) {
                this.initializeCycle(this.currentCycle);
            }
            return this.scorecard.cycles[this.currentCycle];
        },
        
        // Add points to a player's score
        addPlayerPoints: function(team, playerId, points) {
            try {
                const currentCycle = this.getCurrentCycle();
                const teamKey = `team${team}Players`;
                const scoresKey = `team${team}Scores`;
                
                const playerIndex = currentCycle[teamKey].indexOf(playerId);
                if (playerIndex !== -1) {
                    currentCycle[scoresKey][playerIndex] = (currentCycle[scoresKey][playerIndex] || 0) + points;
                    this.updateScores();
                    return true;
                }
                return false;
            } catch (error) {
                console.error('Error adding player points:', error);
                return false;
            }
        },
        
        // Add bonus points to a team
        addBonusPoints: function(team, points) {
            try {
                console.log(`[DEBUG] Adding ${points} bonus points to team ${team}`);
                
                // Get the current cycle and ensure it's properly initialized
                const currentCycle = this.getCurrentCycle();
                
                // Initialize bonus object if it doesn't exist
                if (!currentCycle.bonus) {
                    currentCycle.bonus = { 
                        team1: 0, 
                        team2: 0, 
                        parts: [0, 0, 0] 
                    };
                }
                
                // Convert points to number to ensure proper addition
                points = parseInt(points) || 0;
                
                // Update the bonus points for the team
                currentCycle.bonus[`team${team}`] = (parseInt(currentCycle.bonus[`team${team}`]) || 0) + points;
                
                // For backward compatibility, also update the old format
                currentCycle[`team${team}Bonus`] = currentCycle.bonus[`team${team}`];
                
                console.log(`[DEBUG] Updated bonus for team ${team}:`, currentCycle.bonus);
                
                // Update the scores to reflect the bonus points
                this.updateScores();
                
                // Log the current scorecard state
                console.log('--- Scorecard after bonus update ---');
                console.log(JSON.stringify(this.scorecard, null, 2));
                
                return true;
            } catch (error) {
                console.error('Error adding bonus points:', error);
                console.error('Error details:', {
                    team: team,
                    points: points,
                    currentCycle: this.currentCycle,
                    scorecard: this.scorecard
                });
                return false;
            }
        },
        
        // Save the current state
        saveState: function() {
            try {
                if (this.serverData && this.serverData.game && this.serverData.game.id) {
                    localStorage.setItem(`gameState_${this.serverData.game.id}`, JSON.stringify({
                        currentCycle: this.currentCycle,
                        scorecard: this.scorecard
                    }));
                    
                    // Save player states to localStorage
                    localStorage.setItem(`activePlayers_${this.serverData.game.id}`, JSON.stringify(this.activePlayers));
                    
                    // Update UI to reflect changes
                    this.updatePlayerSelectionUI();
                    
                    // Update scorecard preview
                    this.updateScorecardPreview();
                    
                    // Log the updated scorecard for debugging
                    console.log('Updated scorecard:', this.scorecard);
                }
            } catch (error) {
                console.error('Error saving game state:', error);
            }
        },
        
        // Update player selection UI based on active status
        updatePlayerSelectionUI: function() {
            console.log('Updating player selection UI for cycle', this.currentCycle);
            
            // Ensure current cycle exists
            if (!this.scorecard.cycles[this.currentCycle]) {
                this.initializeCycle(this.currentCycle);
            }
            
            const currentCycle = this.scorecard.cycles[this.currentCycle];
            
            // Ensure active player arrays exist
            if (!currentCycle.team1ActivePlayers) currentCycle.team1ActivePlayers = [];
            if (!currentCycle.team2ActivePlayers) currentCycle.team2ActivePlayers = [];
            
            console.log('Current cycle active players:', {
                team1: currentCycle.team1ActivePlayers,
                team2: currentCycle.team2ActivePlayers
            });
            
            // Update team 1 player checkboxes and sync with activePlayers
            const team1Container = document.getElementById('team1Players');
            if (team1Container) {
                const checkboxes = team1Container.querySelectorAll('.player-checkbox');
                const activePlayerIds = [];
                
                checkboxes.forEach((checkbox) => {
                    const playerId = checkbox.dataset.playerId;
                    const isChecked = checkbox.checked;
                    
                    // Track active player IDs
                    if (isChecked) {
                        activePlayerIds.push(parseInt(playerId) || playerId);
                    }
                    
                    // Update the checkbox state based on the player's active status
                    const player = this.playersTeam1.find(p => p.id == playerId || p.id === playerId);
                    if (player) {
                        checkbox.checked = isChecked;
                    }
                });
                
                // Update activePlayers with the list of active player IDs
                this.activePlayers.team1 = activePlayerIds;
            }
            
            // Update team 2 player checkboxes and sync with activePlayers
            const team2Container = document.getElementById('team2Players');
            if (team2Container) {
                const checkboxes = team2Container.querySelectorAll('.player-checkbox');
                const activePlayerIds = [];
                
                checkboxes.forEach((checkbox) => {
                    const playerId = checkbox.dataset.playerId;
                    const isChecked = checkbox.checked;
                    
                    // Track active player IDs
                    if (isChecked) {
                        activePlayerIds.push(parseInt(playerId) || playerId);
                    }
                    
                    // Update the checkbox state based on the player's active status
                    const player = this.playersTeam2.find(p => p.id == playerId || p.id === playerId);
                    if (player) {
                        checkbox.checked = isChecked;
                    }
                });
                
                // Update activePlayers with the list of active player IDs
                this.activePlayers.team2 = activePlayerIds;
            }
            
            console.log('Updated active players state:', this.activePlayers);
        },
        config: {
            game: { id: serverData.game.id },
            QUESTIONS: [],
            BONUSES: []
        },
        serverData: serverData,
        questions: serverData.questions || [],
        bonuses: serverData.bonuses || [],
        
        // Debug method to log questions
        debugQuestions: function() {
            console.group('Debug Questions');
            console.log('Questions array length:', this.questions.length);
            console.log('Questions array content:', this.questions);
            console.log('First question:', this.questions[0]);
            console.groupEnd();
            
            // Also log the server data structure
            console.group('Server Data Structure');
            console.log('Keys in serverData:', Object.keys(serverData));
            console.log('game:', serverData.game);
            console.log('questions array exists:', Array.isArray(serverData.questions));
            console.groupEnd();
        },
        
        // Initialize the game
        loadQuestion: function(index) {
            this.answeredTeams = [false, false];
            this.hasIncorrectAnswer = false;
            console.log('Loading question for index:', index);
            const question = this.questions[index];
            console.log('Question object:', question);
            
            if (question && question.text) {
                const questionTextEl = document.querySelector('.question-text');
                if (questionTextEl) {
                    console.log('Found question text element, formatting text...');
                    questionTextEl.innerHTML = ''; // Clear existing content
                    
                    // Split text into words and create clickable spans
                    const words = question.text.split(' ');
                    words.forEach((word, i) => {
                        const span = document.createElement('span');
                        span.className = 'clickable-word';
                        span.style.cursor = 'pointer';
                        span.style.display = 'inline-block';
                        span.style.margin = '0 2px';
                        span.style.padding = '2px';
                        span.style.borderRadius = '3px';
                        span.style.transition = 'background-color 0.2s';
                        span.dataset.word = word;
                        span.textContent = word + ' '; // Add space after each word
                        
                        // Add click event directly to the span
                        span.addEventListener('click', (e) => {
                            console.log('Word clicked:', word);
                            console.log('Game state:', window.gameState ? 'exists' : 'undefined');
                            if (window.gameState && window.gameState.openScoringModal) {
                                console.log('Calling openScoringModal');
                                window.gameState.openScoringModal(span, word, i);
                            } else {
                                console.error('gameState or openScoringModal not found');
                            }
                            e.stopPropagation();
                        });
                        
                        span.addEventListener('mouseover', () => {
                            span.style.backgroundColor = '#e9ecef';
                        });
                        
                        span.addEventListener('mouseout', () => {
                            span.style.backgroundColor = 'transparent';
                        });
                        
                        questionTextEl.appendChild(span);
                        
                        // Add space after each word except the last one
                        if (i < words.length - 1) {
                            questionTextEl.appendChild(document.createTextNode(' '));
                        }
                    });
                    
                    console.log('Question text loaded and click handlers attached');
                } else {
                    console.error('Question text element not found');
                }
            } else {
                console.error('No question text found for index:', index);
            }
        },

        // Initialize event listeners - simplified version
        initEventListeners: function() {
            // Remove any existing listeners first
            const oldSkipBtn = document.getElementById('skipToNextCycleBtn');
            if (oldSkipBtn) {
                const newSkipBtn = oldSkipBtn.cloneNode(true);
                oldSkipBtn.parentNode.replaceChild(newSkipBtn, oldSkipBtn);
                
                // Add new listener with { once: true } to prevent multiple triggers
                newSkipBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopImmediatePropagation();
                    this.skipToNextCycle();
                }, { once: true });
            }
            
            // Simple event delegation for other buttons
            const handleButtonClick = (e) => {
                if (e.target.id === 'markCorrectBtn') {
                    e.preventDefault();
                    e.stopPropagation();
                    this.handleAnswer(true);
                } else if (e.target.id === 'markIncorrectBtn') {
                    e.preventDefault();
                    e.stopPropagation();
                    this.handleAnswer(false);
                } else if (e.target.id === 'throwOutBtn') {
                    e.preventDefault();
                    e.stopPropagation();
                    this.throwOutTossup();
                } else if (e.target.id === 'previousCycleBtn') {
                    e.preventDefault();
                    e.stopPropagation();
                    this.skipToPreviousCycle();
                }
            };
            
            // Add fresh event listeners
            document.body.removeEventListener('click', handleButtonClick);
            document.body.addEventListener('click', handleButtonClick);
        },
        
        // Track which team is eligible for the bonus
        bonusEligibleTeam: null,
        
        // Track if we're in the middle of skipping to prevent duplicate operations
        isSkipping: false,
        
        init: function() {
            try {
                console.log('Initializing game...');
                
                // Initialize server data
                this.serverData = JSON.parse(document.getElementById('server-data').textContent);
                this.questions = this.serverData.questions || [];
                this.bonuses = this.serverData.bonuses || [];
                this.totalCycles = 20; // Standard game is 20 tossups
                
                // Initialize game state
                this.currentWordIndex = 0;
                this.hasAsterisk = false;
                this.currentAnswerer = null;
                this.hasIncorrectAnswer = false;
                this.answeredTeams = [false, false];
                this.validCycles = 0;
                this.isTiebreaker = false;
                
                // Simple scorecard state
                this.scorecardState = {
                    lastUpdate: null
                };
                
                // Initialize scorecard
                this.initializeScorecard();
                
                // Initialize event listeners
                this.initEventListeners();
                
                // Load the first question
                if (this.questions.length > 0) {
                    console.log('Loading first question');
                    this.loadQuestion(0);
                } else {
                    console.error('No questions found to load');
                }
                
                console.log('Game initialization complete');
                
                // Initialize the scorecard preview
                console.log('Initializing scorecard preview...');
                this.updateScorecardPreview();
            } catch (error) {
                console.error('Error initializing game:', error);
            }
        },
        
        // Initialize a single cycle with default values
        initializeCycle: function(cycleIndex) {
            if (!this.scorecard.cycles[cycleIndex]) {
                // Get active players from previous cycle if available, otherwise from server data
                let team1Players = [];
                let team2Players = [];
                
                if (cycleIndex > 0 && this.scorecard.cycles[cycleIndex - 1]) {
                    // Copy players from previous cycle to maintain active state
                    const prevCycle = this.scorecard.cycles[cycleIndex - 1];
                    team1Players = [...(prevCycle.team1Players || [])];
                    team2Players = [...(prevCycle.team2Players || [])];
                } else {
                    // Initialize from server data for first cycle
                    team1Players = this.serverData.playersTeam1 ? 
                        this.serverData.playersTeam1.map(p => ({
                            id: p.id,
                            name: p.name || `Player ${p.id}`,
                            active: true  // All players active by default
                        })) : [];
                        
                    team2Players = this.serverData.playersTeam2 ? 
                        this.serverData.playersTeam2.map(p => ({
                            id: p.id,
                            name: p.name || `Player ${p.id}`,
                            active: true  // All players active by default
                        })) : [];
                }
                
                this.scorecard.cycles[cycleIndex] = {
                    // Active players for this cycle with their details
                    team1Players: JSON.parse(JSON.stringify(team1Players)),
                    team2Players: JSON.parse(JSON.stringify(team2Players)),
                    
                    // Track which players were active in this cycle
                    activePlayers: {
                        team1: team1Players.filter(p => p.active).map(p => p.id),
                        team2: team2Players.filter(p => p.active).map(p => p.id)
                    },
                    
                    // Player scores (corresponding by index to player arrays)
                    team1Scores: Array(team1Players.length).fill(0),
                    team2Scores: Array(team2Players.length).fill(0),
                    
                    // Bonus points for each team
                    team1Bonus: 0,
                    team2Bonus: 0,
                    
                    // Current tossup/bonus state (temporary)
                    currentTossup: null,
                    currentBonus: null,
                    
                    // Track cycle completion state
                    isComplete: false,
                    isThrownOut: false
                };
                
                console.log(`Initialized cycle ${cycleIndex} with active players:`, {
                    team1: this.scorecard.cycles[cycleIndex].activePlayers.team1,
                    team2: this.scorecard.cycles[cycleIndex].activePlayers.team2
                });
            }
            return this.scorecard.cycles[cycleIndex];
        },
        
        // Initialize scorecard
        initializeScorecard: function() {
            this.scorecard = {
                cycles: []
            };
            
            // Initialize all cycles
            for (let i = 0; i < this.questions.length; i++) {
                this.initializeCycle(i);
            }
            
            console.log('Scorecard initialized with', this.questions.length, 'cycles');
        },
        
        // Handle answer (correct/incorrect)
        handleAnswer: function(isCorrect) {
            try {
                // Get the current answerer and team
                const currentAnswerer = this.currentAnswerer;
                if (!currentAnswerer) {
                    console.error('Invalid current answerer in handleAnswer:', currentAnswerer);
                    return;
                }

                const { team, playerIndex, playerName } = currentAnswerer;
                
                // Validate we have the required info
                if (team === undefined || playerIndex === undefined || !playerName) {
                    console.error('Missing required answerer information:', { team, playerIndex, playerName });
                    return;
                }
                
                // Make sure we have the latest scores before proceeding
                this.updateScores();
                const currentQuestion = this.questions[this.currentCycle];
                
                console.log(`[DEBUG] Handling answer for team ${team}, player ${playerName}, isCorrect: ${isCorrect}`);
                
                // Initialize the current cycle if it doesn't exist
                if (!this.scorecard.cycles[this.currentCycle]) {
                    console.log(`[DEBUG] Initializing new cycle ${this.currentCycle} in handleAnswer`);
                    this.scorecard.cycles[this.currentCycle] = {
                        tossup: { 
                            points: null, 
                            team: null, 
                            player: null, 
                            playerIndex: null,
                            team1Answered: false,
                            team2Answered: false
                        },
                        bonus: { team1: 0, team2: 0, parts: [null, null, null] },
                        scores: [[], [], [], []]
                    };
                }
                
                const currentCycle = this.scorecard.cycles[this.currentCycle];
                
                // Check if the team has already answered in this cycle
                const hasTeamAnswered = team === 1 ? currentCycle.tossup.team1Answered : currentCycle.tossup.team2Answered;
                console.log(`[DEBUG] Team ${team} has ${hasTeamAnswered ? 'already' : 'not yet'} answered in this cycle`);
                
                if (hasTeamAnswered) {
                    console.warn(`[WARNING] Team ${team} has already answered this tossup.`);
                    console.log('[DEBUG] Current cycle state:', currentCycle);
                    return;
                }
                
                // Initialize firstIncorrectTeam if it doesn't exist
                if (currentCycle.tossup.firstIncorrectTeam === undefined) {
                    currentCycle.tossup.firstIncorrectTeam = null;
                }
                
                // Ensure tossup object exists
                currentCycle.tossup = currentCycle.tossup || {
                    points: null,
                    team: null,
                    player: null,
                    playerIndex: null,
                    team1Answered: false,
                    team2Answered: false
                };

                // Mark this team as having answered
                if (team === 1) {
                    currentCycle.tossup.team1Answered = true;
                    this.hasTeam1Answered = true;
                    console.log(`[DEBUG] Marked team 1 as having answered`);
                } else {
                    currentCycle.tossup.team2Answered = true;
                    this.hasTeam2Answered = true;
                    console.log(`[DEBUG] Marked team 2 as having answered`);
                }
                
                // If answer is correct, this team is eligible for the bonus
                if (isCorrect) {
                    this.bonusEligibleTeam = team;
                    console.log(`[DEBUG] Team ${team} is eligible for bonus`);
                }

                console.log(`Handling answer for ${playerName} (Team ${team}), Correct: ${isCorrect}`);

                let points = 0;
                let isPower = false;

                if (isCorrect) {
                    // Correct answer logic (10 points, or 15 if before power mark *)
                    const questionText = currentQuestion.question_text;
                    
                    // Create a temporary element to get the plain text content without HTML tags
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = questionText;
                    const plainText = tempDiv.textContent || tempDiv.innerText || '';
                    
                    // Check if there's a power mark (*) in the question
                    const powerMarkIndex = plainText.indexOf('*');
                    
                    // Get all words up to the power mark to count how many words precede it
                    let wordsBeforePower = [];
                    if (powerMarkIndex !== -1) {
                        const textBeforePower = plainText.substring(0, powerMarkIndex);
                        wordsBeforePower = textBeforePower.split(/\s+/).filter(w => w.trim() !== '');
                        
                        console.log('=== SCORING DEBUG ===');
                        console.log('Plain text question:', plainText);
                        console.log('Power mark at position:', powerMarkIndex);
                        console.log('Words before power mark:', wordsBeforePower);
                        console.log('Current word index:', this.currentWordIndex);
                        console.log('Words before power count:', wordsBeforePower.length);
                    }
                    
                    // If power mark exists and current word is before it, it's a power (15 points)
                    isPower = powerMarkIndex !== -1 && this.currentWordIndex < wordsBeforePower.length;
                    points = isPower ? 15 : 10;
                    
                    if (powerMarkIndex !== -1) {
                        console.log('Power scoring:', { 
                            isPower: isPower,
                            points: points,
                            wordIndex: this.currentWordIndex,
                            wordsBeforePower: wordsBeforePower.length,
                            currentWord: this.questions[this.currentCycle].question_text.split(/\s+/).filter(w => w.trim() !== '')[this.currentWordIndex]
                        });
                        console.log('======================');
                    }

                    this.updateScore(team, playerIndex, points, isCorrect, isPower);
                    this.updateAnswerUI(isCorrect, points, playerName, team);
                    this.showBonusSection(team); // Show bonus for the correct team
                    this.endTossup(); // End the tossup, no more answers allowed

                } else {
                    // Incorrect answer logic
                    const otherTeam = team === 1 ? 2 : 1;
                    const otherTeamHasAnswered = otherTeam === 1 ? 
                        currentCycle.tossup.team1Answered : 
                        currentCycle.tossup.team2Answered;
                    
                    // Track if this is the first incorrect answer in this cycle
                    const isFirstIncorrect = currentCycle.tossup.firstIncorrectTeam === null;
                
                    // Get the clicked word from the event target
                    const clickedWord = this.clickedWordElement ? this.clickedWordElement.textContent.trim() : '';
                    const isEndMarker = clickedWord === '///';
                    
                    console.log('Clicked word:', clickedWord, 'Is end marker:', isEndMarker);
            
                    // No penalty for clicking on the end marker, always 0 points
                    // For other cases, first incorrect gets -5, subsequent get 0
                    points = (isFirstIncorrect && !isEndMarker) ? -5 : 0;
                
                    // Update the score and UI before checking for first incorrect
                    this.updateScore(team, playerIndex, points, isCorrect, isPower);
                    this.updateAnswerUI(isCorrect, points, playerName, team);
                    
                    try {
                        const otherTeamName = otherTeam === 1 ? 
                            this.serverData.game.team1 : 
                            this.serverData.game.team2;
                            
                        console.log(`[DEBUG] Processing incorrect answer: firstIncorrectTeam=${currentCycle.tossup.firstIncorrectTeam}, currentTeam=${team}`);
                        
                        // If this is the first incorrect answer, record which team it was
                        if (isFirstIncorrect) {
                            console.log(`[DEBUG] First incorrect answer in cycle ${this.currentCycle} from team ${team}`);
                            currentCycle.tossup.firstIncorrectTeam = team;
                            console.log(`[DEBUG] Updated firstIncorrectTeam to ${currentCycle.tossup.firstIncorrectTeam}`);
                            
                            // First incorrect answer, other team can still answer
                            this.closeScoringModal();
                        } else {
                            // This is a subsequent incorrect answer from the same team
                            // If the other team hasn't answered yet, let them answer
                            if (!otherTeamHasAnswered) {
                                // Do nothing, let them answer
                            } else {
                                // Both teams have answered incorrectly
                                this.endTossup();
                                this.closeScoringModal();
                                this.nextCycle();
                            }
                        }
                    } catch (error) {
                        console.error('Error handling incorrect answer:', error);
                        // Ensure the modal gets closed even if there's an error
                        this.closeScoringModal();
                    }
                }

                // Close the scoring modal
                const modal = bootstrap.Modal.getInstance(document.getElementById('scoringModal'));
                if (modal) {
                    modal.hide();
                }

                // Clear the current answerer to allow the other team to buzz or to end the tossup
                this.currentAnswerer = null;
            } catch (error) {
                console.error('Error in handleAnswer:', error);
            }
        },
        
        // Update score for a team/player
        updateScore: function(teamNum, playerIndex, points, isCorrect, isPower) {
            // Make sure we have the latest cycle data
            const currentCycle = this.getCurrentCycle();
            if (!currentCycle) {
                console.error('No current cycle found in updateScore');
                return;
            }
            console.group('updateScore - Start');
            console.log(`Team: ${teamNum}, Player: ${playerIndex}, Points: ${points}, Correct: ${isCorrect}, Power: ${isPower}`);
            
            const cycle = this.getCurrentCycle();
            if (!cycle) {
                console.error('No current cycle found!');
                console.groupEnd();
                return;
            }
            
            console.log('Current cycle before update:', JSON.parse(JSON.stringify(cycle)));

            // Initialize team players arrays if needed
            if (!cycle[`team${teamNum}Players`]) {
                console.log(`Initializing team${teamNum}Players`);
                cycle[`team${teamNum}Players`] = [...this.serverData[`playersTeam${teamNum}`]];
            }
            
            // Ensure the player index is valid
            if (playerIndex < 0 || playerIndex >= cycle[`team${teamNum}Players`].length) {
                console.error(`Invalid player index ${playerIndex} for team ${teamNum}`);
                console.groupEnd();
                return;
            }
            
            // Initialize scores array if needed
            if (!cycle[`team${teamNum}Scores`]) {
                console.log(`Initializing team${teamNum}Scores`);
                cycle[`team${teamNum}Scores`] = Array(cycle[`team${teamNum}Players`].length).fill(0);
            }
            
            // Update the player's score
            const oldPoints = cycle[`team${teamNum}Scores`][playerIndex] || 0;
            cycle[`team${teamNum}Scores`][playerIndex] = points;
            console.log(`Updated player ${playerIndex} score from ${oldPoints} to ${points}`);
            
            // Initialize the scores array in the cycle if it doesn't exist
            if (!cycle.scores) {
                console.log('Initializing scores array in cycle');
                cycle.scores = [[], [], [], []]; // [team1Scores, team1Bonus, team2Scores, team2Bonus]
            }
            
            // Ensure the scores array has the right structure
            if (!Array.isArray(cycle.scores[teamNum === 1 ? 0 : 2])) {
                console.log('Initializing team scores in cycle.scores');
                cycle.scores[teamNum === 1 ? 0 : 2] = [];
            }
            
            // Update the score in cycle.scores for backward compatibility
            cycle.scores[teamNum === 1 ? 0 : 2][playerIndex] = points;
            
            // Update the tossup information
            const playerData = this.serverData[`playersTeam${teamNum}`][playerIndex];
            const playerName = playerData?.name || `Player ${playerIndex + 1}`;
            
            cycle.tossup = {
                points: points,
                team: teamNum,
                player: playerData,
                playerIndex: playerIndex,
                playerName: playerName,
                isPower: isPower,
                isCorrect: isCorrect,
                timestamp: new Date().toISOString()
            };
            
            console.log('Updated tossup info:', JSON.parse(JSON.stringify(cycle.tossup)));

            // Initialize buzzes array if needed
            if (!cycle.buzzes) {
                console.log('Initializing buzzes array');
                cycle.buzzes = [];
            }
            
            // Add to buzz history
            const buzzData = {
                team: teamNum,
                playerIndex: playerIndex,
                playerName: playerName,
                wordIndex: this.currentWordIndex || 0,
                isCorrect: isCorrect,
                points: points,
                isPower: isPower,
                timestamp: new Date().toISOString()
            };
            
            cycle.buzzes.push(buzzData);
            console.log('Added buzz data:', JSON.parse(JSON.stringify(buzzData)));
            
            // Log the updated cycle state
            console.log('Cycle state after update:', JSON.parse(JSON.stringify(cycle)));
            
            // Update the scores and save state
            console.log('Calling updateScores()');
            this.updateScores();
            
            console.log('Calling saveState()');
            this.saveState();
            
            // Log the full scorecard state
            console.group('Full Scorecard State After Update');
            console.log('Current cycle index:', this.currentCycle);
            console.log('Full scorecard:', JSON.parse(JSON.stringify(this.scorecard)));
            console.groupEnd();
            
            console.groupEnd(); // End updateScore group
        },
        
        // Update the answer UI based on correctness and points
        updateAnswerUI: function(isCorrect, points, playerName, teamNum) {
            try {
                const playerSelection = document.getElementById('playerSelectionArea');
                const scoreSelection = document.getElementById('scoreSelectionArea');
                const scoreResult = document.getElementById('scoreResult');
                
                if (scoreResult) {
                    let resultText = '';
                    if (isCorrect) {
                        const pointsText = points === 15 ? '15 (Power)' : '10 (Correct)';
                        resultText = `${playerName} answered correctly for ${pointsText} points!`;
                    } else {
                        resultText = points === -5 ? 
                            `${playerName} answered incorrectly. -5 points.` : 
                            `${playerName} answered incorrectly. 0 points.`;
                    }
                    scoreResult.textContent = resultText;
                }
                
                // Show score result and hide player selection
                if (playerSelection) playerSelection.style.display = 'none';
                if (scoreSelection) scoreSelection.style.display = 'block';
                
                // Update button states
                const markCorrectBtn = document.getElementById('markCorrectBtn');
                const markIncorrectBtn = document.getElementById('markIncorrectBtn');
                
                if (markCorrectBtn) markCorrectBtn.disabled = true;
                if (markIncorrectBtn) markIncorrectBtn.disabled = true;
                
                // If answer was incorrect and other team can still answer, re-enable word clicks
                if (!isCorrect && this.hasIncorrectAnswer && this.currentAnswerer.team === 1) {
                    this.currentAnswerer = null;
                }
                
            } catch (error) {
                console.error('Error in updateAnswerUI:', error);
            }
        },
        
        // Show a message to the user
        showMessage: function(message) {
            try {
                console.log('[DEBUG] Showing message:', message);
                // You can implement a more sophisticated message display here if needed
                // For now, we'll just log to console and use alert as a fallback
                alert(message);
            } catch (error) {
                console.error('Error in showMessage:', error);
            }
        },
        
        // Close the scoring modal
        closeScoringModal: function() {
            try {
                const modal = bootstrap.Modal.getInstance(document.getElementById('scoringModal'));
                if (modal) {
                    modal.hide();
                } else {
                    // If we can't get the modal instance, try hiding it directly
                    const modalElement = document.getElementById('scoringModal');
                    if (modalElement) {
                        const bsModal = new bootstrap.Modal(modalElement);
                        bsModal.hide();
                    }
                }
            } catch (error) {
                console.error('Error closing modal:', error);
            }
        },
        
        // Show bonus section for a team
        showBonusSection: function(teamNum) {
            console.log('Showing bonus section for team:', teamNum);
            const bonusSection = document.getElementById('bonusSection');
            if (bonusSection) {
                bonusSection.style.display = 'block';
                // Load bonus questions for the current cycle
                this.loadBonus(this.currentCycle);
                
                // Update the UI to show which team is answering the bonus
                const bonusTeamIndicator = document.getElementById('bonusTeamIndicator');
                if (bonusTeamIndicator) {
                    bonusTeamIndicator.textContent = `Team ${teamNum} is answering the bonus`;
                }
                
                // Scroll to bonus section
                bonusSection.scrollIntoView({ behavior: 'smooth' });
                
                // Close the scoring modal
                const modal = bootstrap.Modal.getInstance(document.getElementById('scoringModal'));
                if (modal) {
                    modal.hide();
                }
            }
        },
        
        // End the current tossup (no more answers allowed)
        endTossup: function() {
            console.log(`[DEBUG] Ending tossup for cycle ${this.currentCycle}`);
            
            // Log state before reset
            const currentCycle = this.scorecard.cycles[this.currentCycle];
            console.log(`[DEBUG] Pre-reset state for cycle ${this.currentCycle}:`, {
                currentAnswerer: this.currentAnswerer,
                team1Answered: currentCycle?.tossup?.team1Answered,
                team2Answered: currentCycle?.tossup?.team2Answered
            });
            
            // Don't reset currentAnswerer here - we need it for bonus scoring
            // Just reset the answer tracking flags
            this.hasIncorrectAnswer = false;
            
            // Reset team answer tracking for the current cycle
            if (currentCycle && currentCycle.tossup) {
                // Only reset these if the tossup wasn't answered correctly
                if (!currentCycle.tossup.points || currentCycle.tossup.points <= 0) {
                    currentCycle.tossup.team1Answered = false;
                    currentCycle.tossup.team2Answered = false;
                }
            }
            
            // Disable all clickable words
            document.querySelectorAll('.clickable-word').forEach(word => {
                word.style.cursor = 'default';
                word.style.pointerEvents = 'none';
            });
            
            // Enable next cycle button
            const nextCycleBtn = document.getElementById('nextCycleBtn');
            if (nextCycleBtn) {
                nextCycleBtn.disabled = false;
            }
            
            console.log(`[DEBUG] Tossup ${this.currentCycle} ended, answer tracking reset`);
        },
        
        // throwOutTossup function is defined later in the file
        
        // Reset active selections for points and players
        resetActiveSelections: function() {
            // Reset active points selection
            document.querySelectorAll('.tossup-points').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Reset any active player selections
            document.querySelectorAll('.player-btn').forEach(btn => {
                btn.classList.remove('active');
            });
        },
        
        // Clear current cycle's scoring
        clearCurrentCycle: function() {
            if (!confirm('Are you sure you want to clear all scoring for this cycle? This cannot be undone.')) {
                return;
            }
            
            const cycle = this.getCurrentCycle();
            cycle.tossup = cycle.tossup || {};
            
            // Update tossup data
            cycle.tossup.points = null;
            cycle.tossup.team = null;
            cycle.tossup.player = null;
            cycle.tossup.playerIndex = null;
            
            // Update answered states
            cycle.tossup.team1Answered = false;
            cycle.tossup.team2Answered = false;
            this.hasTeam1Answered = false;
            this.hasTeam2Answered = false;
            
            // Reset bonus data
            cycle.bonus = { team1: 0, team2: 0, parts: [null, null, null] };
            
            // Reset scores
            cycle.team1Scores = [];
            cycle.team2Scores = [];
            
            // Hide bonus section
            const bonusSection = document.getElementById('bonusSection');
            if (bonusSection) bonusSection.style.display = 'none';
            
            // Update UI
            this.updateUI();
            this.updateScores();
            this.saveProgress();
            
            // Show feedback
            alert('Cycle scoring has been reset. You can now re-enter the scores.');
        },
        
        // Update UI
        updateUI: function() {
            const currentCycle = this.getCurrentCycle();
            
            // Update current cycle display with clear button
            const cycleDisplay = document.getElementById('currentCycleDisplay');
            if (cycleDisplay) {
                // Only show clear button if there's something to clear
                const hasScoring = (currentCycle.tossup && 
                                 (currentCycle.tossup.points !== null || 
                                  currentCycle.tossup.team1Answered || 
                                  currentCycle.tossup.team2Answered)) ||
                               (currentCycle.bonus && 
                                (currentCycle.bonus.team1 > 0 || 
                                 currentCycle.bonus.team2 > 0));
                
                cycleDisplay.innerHTML = `
                    <span>${this.currentCycle + 1}</span>
                    ${hasScoring ? `
                    <button class="btn btn-sm btn-outline-danger ms-2" 
                            onclick="event.stopPropagation(); gameState.clearCurrentCycle()"
                            title="Clear all scoring for this cycle">
                        <i class="bi bi-x-circle"></i> Clear
                    </button>` : ''}
                `;
            }
            
            // Update tossup buttons state
            if (currentCycle.tossup) {
                // Mark which team (if any) has answered
                if (currentCycle.tossup.team1Answered) {
                    document.querySelectorAll('.team1-answer-btn').forEach(btn => {
                        btn.classList.add('active');
                    });
                }
                if (currentCycle.tossup.team2Answered) {
                    document.querySelectorAll('.team2-answer-btn').forEach(btn => {
                        btn.classList.add('active');
                    });
                }
                
                // Mark correct/incorrect answers
                if (currentCycle.tossup.points !== null) {
                    const points = currentCycle.tossup.points;
                    const team = currentCycle.tossup.team;
                    const isPower = points === 15;
                    
                    // Highlight the selected points button
                    const pointsBtn = document.querySelector(`.tossup-points[data-points="${points}"][data-team="${team}"]`);
                    if (pointsBtn) {
                        pointsBtn.classList.add('active');
                        
                        // Add visual indicator for power
                        if (isPower) {
                            pointsBtn.innerHTML += ' <span class="badge bg-warning text-dark">POWER</span>';
                        }
                    }
                }
            }
            
            // Update tossup buttons
            document.querySelectorAll('.tossup-points').forEach(btn => {
                btn.classList.remove('active');
                // Only mark as active if points match and either:
                // 1. Both team and points match, or
                // 2. It's a 0-point tossup and the button is the 0-point button
                if ((parseInt(btn.dataset.points) === currentCycle.tossup.points && 
                     btn.dataset.team === currentCycle.tossup.team) ||
                    (currentCycle.tossup.points === 0 && 
                     parseInt(btn.dataset.points) === 0 && 
                     currentCycle.tossup.team === null)) {
                    btn.classList.add('active');
                }
            });
            
            // Update player buttons
            document.querySelectorAll('.player-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.playerId === currentCycle.tossup.player) {
                    btn.classList.add('active');
                }
            });
            
            // Update bonus buttons
            if (currentCycle.bonus && currentCycle.bonus.parts) {
                currentCycle.bonus.parts.forEach((points, index) => {
                    if (points !== null) {
                        document.querySelectorAll(`.bonus-btn[data-part="${index + 1}"]`).forEach(btn => {
                            btn.classList.remove('active');
                            if (parseInt(btn.dataset.points) === points) {
                                btn.classList.add('active');
                            }
                        });
                    }
                });
            }
        },
        
        updateScores: function() {
            // Track points by type (tossup and bonus) for each team
            let team1Tossup = 0;
            let team1Bonus = 0;
            let team2Tossup = 0;
            let team2Bonus = 0;
            
            // Calculate total scores
            this.scorecard.cycles.forEach(cycle => {
                if (cycle.valid === false) return; // Skip thrown-out cycles
                
                // Initialize scores array if it doesn't exist
                if (!cycle.scores) {
                    const team1Length = this.serverData.playersTeam1 ? this.serverData.playersTeam1.length : 0;
                    const team2Length = this.serverData.playersTeam2 ? this.serverData.playersTeam2.length : 0;
                    cycle.scores = [
                        Array(team1Length).fill(0), // Team 1 player points
                        0,                         // Team 1 bonus points
                        Array(team2Length).fill(0), // Team 2 player points
                        0                          // Team 2 bonus points
                    ];
                }
                
                // Get scores from the cycle
                const [team1Players, team1CycleBonus, team2Players, team2CycleBonus] = cycle.scores;
                
                // Get team-specific scores if they exist (new format)
                const team1Scores = cycle.team1Scores || team1Players || [];
                const team2Scores = cycle.team2Scores || team2Players || [];
                
                // Calculate tossup points (can be negative for negs)
                // Use team-specific scores if available, otherwise fall back to the legacy scores array
                const team1TossupCycle = team1Scores.reduce((sum, points) => sum + (parseInt(points) || 0), 0);
                const team2TossupCycle = team2Scores.reduce((sum, points) => sum + (parseInt(points) || 0), 0);
                
                // Enhanced debug logging for tossup points
                console.groupCollapsed(`Cycle ${this.currentCycle} - Tossup Points`);
                console.log(`Team 1 Tossup: ${team1TossupCycle} (${team1Scores.join(', ')})`);
                console.log(`Team 2 Tossup: ${team2TossupCycle} (${team2Scores.join(', ')})`);
                console.groupEnd();
                
                // Get bonus points for this cycle - check both the bonus object and scores array
                let team1BonusCycle = 0;
                let team2BonusCycle = 0;
                
                // First check the bonus object (new format)
                if (cycle.bonus) {
                    team1BonusCycle = parseInt(cycle.bonus.team1) || 0;
                    team2BonusCycle = parseInt(cycle.bonus.team2) || 0;
                }
                
                // If no bonus points in the bonus object, fall back to the scores array (legacy format)
                if (team1BonusCycle === 0) {
                    team1BonusCycle = parseInt(team1CycleBonus) || 0;
                }
                if (team2BonusCycle === 0) {
                    team2BonusCycle = parseInt(team2CycleBonus) || 0;
                }
                
                // Update running totals
                team1Tossup += team1TossupCycle;
                team1Bonus += team1BonusCycle;
                team2Tossup += team2TossupCycle;
                team2Bonus += team2BonusCycle;
                
                // Update the old format for backward compatibility
                cycle.team1Bonus = team1BonusCycle;
                cycle.team2Bonus = team2BonusCycle;
                
                // Update the tossup object for backward compatibility
                const lastTeam1Player = team1Players.lastIndexOf(Math.max(...team1Players));
                const lastTeam2Player = team2Players.lastIndexOf(Math.max(...team2Players));
                
                if (lastTeam1Player >= 0 && team1Players[lastTeam1Player] > 0) {
                    cycle.tossup = cycle.tossup || {};
                    cycle.tossup.team = 1;
                    cycle.tossup.player = this.serverData.playersTeam1[lastTeam1Player];
                    cycle.tossup.points = team1Players[lastTeam1Player];
                } else if (lastTeam2Player >= 0 && team2Players[lastTeam2Player] > 0) {
                    cycle.tossup = cycle.tossup || {};
                    cycle.tossup.team = 2;
                    cycle.tossup.player = this.serverData.playersTeam2[lastTeam2Player];
                    cycle.tossup.points = team2Players[lastTeam2Player];
                }
            });
            
            // Update score display with separate tossup and bonus points
            const team1ScoreElement = document.getElementById('team1Score');
            const team1TossupElement = document.getElementById('team1TossupScore');
            const team1BonusElement = document.getElementById('team1BonusScore');
            const team2ScoreElement = document.getElementById('team2Score');
            const team2TossupElement = document.getElementById('team2TossupScore');
            const team2BonusElement = document.getElementById('team2BonusScore');
            
            // Update Team 1 scores
            if (team1TossupElement) {
                team1TossupElement.textContent = team1Tossup > 0 ? `+${team1Tossup}` : team1Tossup;
                team1TossupElement.style.fontWeight = 'bold';
                team1TossupElement.style.color = team1Tossup > 0 ? 'green' : (team1Tossup < 0 ? 'red' : 'inherit');
            }
            
            if (team1BonusElement) {
                team1BonusElement.textContent = team1Bonus > 0 ? `+${team1Bonus}` : team1Bonus;
                team1BonusElement.style.fontWeight = 'bold';
                team1BonusElement.style.color = team1Bonus > 0 ? 'green' : 'inherit';
            }
            
            if (team1ScoreElement) {
                team1ScoreElement.textContent = team1Tossup + team1Bonus;
                team1ScoreElement.style.fontWeight = 'bold';
                team1ScoreElement.style.color = (team1Tossup + team1Bonus) > 0 ? 'green' : 'inherit';
            }
            
            // Update Team 2 scores
            if (team2TossupElement) {
                team2TossupElement.textContent = team2Tossup > 0 ? `+${team2Tossup}` : team2Tossup;
                team2TossupElement.style.fontWeight = 'bold';
                team2TossupElement.style.color = team2Tossup > 0 ? 'green' : (team2Tossup < 0 ? 'red' : 'inherit');
            }
            
            if (team2BonusElement) {
                team2BonusElement.textContent = team2Bonus > 0 ? `+${team2Bonus}` : team2Bonus;
                team2BonusElement.style.fontWeight = 'bold';
                team2BonusElement.style.color = team2Bonus > 0 ? 'green' : 'inherit';
            }
            
            if (team2ScoreElement) {
                team2ScoreElement.textContent = team2Tossup + team2Bonus;
                team2ScoreElement.style.fontWeight = 'bold';
                team2ScoreElement.style.color = (team2Tossup + team2Bonus) > 0 ? 'green' : 'inherit';
            }
            
            // Log the scorecard object for debugging
            console.log('Current Scorecard Object:', JSON.parse(JSON.stringify(this.scorecard)));
        },
        
        // Update the scorecard display
        updateScorecard: function() {
            // Clean up any existing console groups
            if (console.group) {
                try {
                    while (console.group()) {
                        console.groupEnd();
                    }
                } catch (e) {
                    // Ignore errors from groupEnd()
                }
            }
            
            const scorecardElement = document.getElementById('scorecardPreview');
            if (!scorecardElement) return;
            
            // Calculate team totals
            const team1Total = this.calculateTeamTotal(1);
            const team2Total = this.calculateTeamTotal(2);
            
            // Calculate bonus and tossup totals directly from the scorecard data
            let team1TossupTotal = 0;
            let team2TossupTotal = 0;
            let team1BonusTotal = 0;
            let team2BonusTotal = 0;
            
            // Process each cycle to calculate totals
            this.scorecard.cycles.forEach(cycle => {
                if (cycle.valid === false) return; // Skip thrown-out cycles
                
                // Calculate tossup points from team scores (same as in updateScores)
                const team1Scores = cycle.team1Scores || (cycle.scores && cycle.scores[0]) || [];
                const team2Scores = cycle.team2Scores || (cycle.scores && cycle.scores[2]) || [];
                
                const team1TossupCycle = team1Scores.reduce((sum, points) => sum + (parseInt(points) || 0), 0);
                const team2TossupCycle = team2Scores.reduce((sum, points) => sum + (parseInt(points) || 0), 0);
                
                team1TossupTotal += team1TossupCycle;
                team2TossupTotal += team2TossupCycle;
                
                // Bonus points (keep the existing bonus calculation)
                if (cycle.bonus) {
                    if (cycle.bonus.team === 1) {
                        team1BonusTotal += cycle.bonus.points || 0;
                    } else if (cycle.bonus.team === 2) {
                        team2BonusTotal += cycle.bonus.points || 0;
                    }
                }
            });
            
            // Create a table to display the scorecard
            let html = `
                <div class="table-responsive">
                    <table class="table table-bordered table-hover">
                        <thead class="table-light">
                            <tr>
                                <th>Cycle</th>
                                <th class="text-center">${this.serverData.game.team1}<br>Tossup (${team1TossupTotal})</th>
                                <th class="text-center">${this.serverData.game.team1}<br>Bonus (${team1BonusTotal})</th>
                                <th class="text-center">${this.serverData.game.team2}<br>Tossup (${team2TossupTotal})</th>
                                <th class="text-center">${this.serverData.game.team2}<br>Bonus (${team2BonusTotal})</th>
                                <th>Action</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            // Add a row for each cycle
            for (let i = 0; i < this.totalCycles; i++) {
                const cycle = this.scorecard.cycles[i] || { tossup: {}, bonus: {}, buzzes: [] };
                const tossup = cycle.tossup || { team: null, player: null, points: 0 };
                const bonus = cycle.bonus || { team: null, points: 0, parts: [null, null, null] };
                
                // Get player name if available
                let playerName = '';
                if (tossup.team && tossup.playerIndex !== undefined) {
                    const players = tossup.team === 1 ? this.serverData.playersTeam1 : this.serverData.playersTeam2;
                    const player = players && players[tossup.playerIndex];
                    playerName = player ? ` (${player.name || player})` : '';
                }
                
                // Format tossup points
                let tossup1Display = '';
                let tossup2Display = '';
                let bonus1Display = '';
                let bonus2Display = '';
                
                // Tossup display
                if (tossup.team === 1) {
                    tossup1Display = tossup.points > 0 ? `+${tossup.points}${playerName}` : 
                                  tossup.points < 0 ? `${tossup.points}${playerName}` : '';
                } else if (tossup.team === 2) {
                    tossup2Display = tossup.points > 0 ? `+${tossup.points}${playerName}` : 
                                   tossup.points < 0 ? `${tossup.points}${playerName}` : '';
                }
                
                // Bonus display - show each part's score if available
                if (bonus.team === 1) {
                    if (bonus.parts && bonus.parts.every(p => p !== null)) {
                        // Show each part's score ( or )
                        const partsDisplay = bonus.parts.map(p => p ? ' ' : ' ').join(' / ');
                        bonus1Display = `${partsDisplay} (${bonus.points})`;
                    } else if (bonus.points !== undefined) {
                        bonus1Display = bonus.points > 0 ? `+${bonus.points}` : '0';
                    }
                } else if (bonus.team === 2) {
                    if (bonus.parts && bonus.parts.every(p => p !== null)) {
                        // Show each part's score ( or )
                        const partsDisplay = bonus.parts.map(p => p ? ' ' : ' ').join(' / ');
                        bonus2Display = `${partsDisplay} (${bonus.points})`;
                    } else if (bonus.points !== undefined) {
                        bonus2Display = bonus.points > 0 ? `+${bonus.points}` : '0';
                    }
                }
                
                // Add row
                html += `
                    <tr class="${i === this.currentCycle ? 'table-info' : ''}">
                        <td>${i + 1}</td>
                        <td class="text-center">${tossup1Display || ''}</td>
                        <td class="text-center">${bonus1Display || ''}</td>
                        <td class="text-center">${tossup2Display || ''}</td>
                        <td class="text-center">${bonus2Display || ''}</td>
                        <td class="text-center">
                            <button class="btn btn-sm btn-outline-primary" onclick="gameState.goToCycle(${i})">
                                <i class="bi bi-pencil"></i> Edit
                            </button>
                        </td>
                    </tr>
                `;
            }
            
            // Add total row with team totals
            html += `
                    <tr class="table-secondary fw-bold">
                        <td>Total</td>
                        <td class="text-center">${team1TossupTotal}</td>
                        <td class="text-center">${team1BonusTotal}</td>
                        <td class="text-center">${team2TossupTotal}</td>
                        <td class="text-center">${team2BonusTotal}</td>
                        <td></td>
                    </tr>
                    <tr class="table-light fw-bold">
                        <td>Grand Total</td>
                        <td colspan="2" class="text-center">${team1TossupTotal + team1BonusTotal}</td>
                        <td colspan="2" class="text-center">${team2TossupTotal + team2BonusTotal}</td>
                        <td></td>
                    </tr>
                </tbody>
                </table>
            </div>
            `;
            
            scorecardElement.innerHTML = html;
        },
        
        // Update progress
        updateProgress: function() {
            const progress = Math.round((this.currentCycle / 20) * 100);
            const progressBar = document.getElementById('progressBar');
            const progressPercentage = document.getElementById('progressPercentage');
            
            if (progressBar && progressPercentage) {
                const width = Math.min(100, Math.max(5, progress)); // Keep at least 5% width for visibility
                progressBar.style.width = `${width}%`;
                progressBar.setAttribute('aria-valuenow', width);
                progressBar.querySelector('.visually-hidden').textContent = `${width}% Complete`;
                progressPercentage.textContent = `${width}% Complete`;
            }
        },
        
        // Save progress
        saveProgress: function() {
            try {
                const data = {
                    scorecard: this.scorecard,
                    currentCycle: this.currentCycle,
                    timestamp: new Date().toISOString()
                };
                
                localStorage.setItem(`game_${this.serverData.game.id}_progress`, JSON.stringify(data));
                // alert('Progress saved successfully!');
            } catch (error) {
                console.error('Error saving progress:', error);
                return false;
            }
        },
        
        // Load saved progress
        loadSavedProgress: function() {
            try {
                const savedData = localStorage.getItem(`game_${this.serverData.game.id}_progress`);
                if (savedData) {
                    const data = JSON.parse(savedData);
                    this.scorecard = data.scorecard;
                    this.currentCycle = data.currentCycle;
                    
                    // Update UI
                    this.updateUI();
                    this.updateScores();
                    this.updateProgress();
                    
                    console.log('Loaded saved progress:', data);
                }
            } catch (error) {
                console.error('Error loading saved progress:', error);
            }
        },
        
        // Submit the game
        submitGame: function() {
            // Update player states for the final cycle
            this.updateActivePlayers();
            
            // Log the final scorecard for debugging
            console.log('Submitting scorecard:', JSON.stringify(this.scorecard, null, 2));
            
            // Show loading state
            const submitBtn = document.getElementById('submitGameBtn');
            const nextCycleBtn = document.getElementById('nextCycleBtn');
            
            if (submitBtn) {
                submitBtn.disabled = true;
                submitBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Submitting...';
            }
            
            if (nextCycleBtn) {
                nextCycleBtn.disabled = true;
                nextCycleBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Submitting...';
            }
            
            // Prepare the scorecard data using the same format as download
            const cycles = [];
            
            // Process each cycle the same way as in downloadScorecard
            for (let cycleIndex = 0; cycleIndex < this.scorecard.cycles.length; cycleIndex++) {
                const cycle = this.scorecard.cycles[cycleIndex];
                
                if (!cycle || cycle.isThrownOut) {
                    continue;
                }
                
                // Prepare cycle data with all possible fields
                const cycleData = {
                    team1Players: cycle.team1Players || [],
                    team2Players: cycle.team2Players || [],
                    team1Scores: (cycle.team1Scores || (cycle.scores && cycle.scores[0]) || []),
                    team2Scores: (cycle.team2Scores || (cycle.scores && cycle.scores[2]) || []),
                    team1Bonus: (cycle.team1Bonus !== undefined ? cycle.team1Bonus : (cycle.bonus && cycle.bonus.team1) || 0),
                    team2Bonus: (cycle.team2Bonus !== undefined ? cycle.team2Bonus : (cycle.bonus && cycle.bonus.team2) || 0),
                    buzzes: cycle.buzzes || [],
                    words: cycle.words || [],
                    scores: cycle.scores || []
                };
                
                // Clean the cycle data
                const cleanedCycle = this.cleanCycleData(cycleData);
                
                // Only add the cycle if it has some meaningful data
                const hasData = Object.keys(cleanedCycle.team1).length > 0 ||
                              Object.keys(cleanedCycle.team2).length > 0 ||
                              cleanedCycle.team1Bonus !== 0 ||
                              cleanedCycle.team2Bonus !== 0 ||
                              Object.keys(cleanedCycle.buzzes).length > 0;
                
                if (hasData) {
                    cycles.push(cleanedCycle);
                }
            }
            
            const scorecardData = {
                scorecard: cycles
            };
            
            console.log('Sending scorecard data:', JSON.parse(JSON.stringify(scorecardData)));
            
            // No confirmation needed, proceed with submission
            
            // Get CSRF token from meta tag
            const csrfToken = document.querySelector('meta[name="csrf-token"]').getAttribute('content');
            
            // Send the data to the server
            fetch(`/reader/game/${this.serverData.game.id}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrfToken
                },
                body: JSON.stringify(scorecardData)
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(data => {
                console.log('Game submitted successfully:', data);
                // Redirect to tournament games page
                window.location.href = `/reader/tournament/${this.serverData.tournament.id}`;
            })
            .catch((error) => {
                console.error('Error submitting game:', error);
                console.log('Game submission failed:', error.message);
                
                // Re-enable buttons on error
                if (submitBtn) {
                    submitBtn.disabled = false;
                    submitBtn.textContent = 'Submit Game';
                }
                if (nextCycleBtn) {
                    nextCycleBtn.disabled = false;
                    nextCycleBtn.textContent = 'Next Cycle';
                }
            });
        },
        
        // Completely remove the current cycle and all its data
        throwOutTossup: function() {
            // No confirmation dialog, just log the action
            console.log('Throwing out tossup for cycle', this.currentCycle);
            
            console.log(`Completely removing cycle ${this.currentCycle} from scorecard`);
            
            // Remove the cycle from the scorecard if it exists
            if (this.scorecard.cycles[this.currentCycle]) {
                delete this.scorecard.cycles[this.currentCycle];
            }
            
            // Also remove any bonus data for this cycle
            if (this.scorecard.bonuses && this.scorecard.bonuses[this.currentCycle]) {
                delete this.scorecard.bonuses[this.currentCycle];
            }
            
            // Reset any active selections
            this.resetActiveSelections();
            
            // Save the current cycle number before potentially changing it
            const currentCycle = this.currentCycle;
            
            // Move to the next question without incrementing the cycle counter
            this.loadQuestion(currentCycle + 1);
            
            // Show a message to the user
            this.showMessage('Tossup has been completely removed. Moving to next question...');
            
            // Force update the UI to reflect the changes
            this.updateScorecardPreview();
            this.updateScores();
            
            // Save the updated scorecard
            this.saveProgress();
        },
        
        // Update the progress bar based on current cycle
        updateProgressBar: function() {
            this.updateProgress(); // Reuse the updateProgress function
        },
        
        // Skip to next cycle while properly recording active players
        skipToNextCycle: function() {
            // Prevent multiple simultaneous skips
            if (this.isSkipping) return;
            this.isSkipping = true;
            
            console.log('[SKIP] Skip button clicked');
            
            // Confirm with user
            if (!confirm('Skip to next question? This will preserve all tossup scores and advance to the next question.')) {
                this.isSkipping = false;
                return;
            }
            
            try {
                // Save the current cycle's state
                const currentCycle = this.getCurrentCycle();
                
                // Ensure we have valid player arrays
                if (!currentCycle.team1Players) currentCycle.team1Players = [];
                if (!currentCycle.team2Players) currentCycle.team2Players = [];
                
                // Initialize scores arrays if they don't exist
                if (!currentCycle.team1Scores) {
                    currentCycle.team1Scores = Array(currentCycle.team1Players.length).fill(0);
                }
                if (!currentCycle.team2Scores) {
                    currentCycle.team2Scores = Array(currentCycle.team2Players.length).fill(0);
                }
                
                // Mark the cycle as valid
                currentCycle.valid = true;
                
                // Save the current team totals before moving on
                currentCycle.team1Total = this.calculateTeamTotal(1);
                currentCycle.team2Total = this.calculateTeamTotal(2);
                
                console.log('[SKIP] Recorded zero scores for active players in cycle:', {
                    cycle: this.currentCycle,
                    team1Players: currentCycle.team1Players,
                    team2Players: currentCycle.team2Players,
                    team1Scores: currentCycle.team1Scores,
                    team2Scores: currentCycle.team2Scores
                });
                
                // Mark current cycle as valid for progress tracking
                this.validCycles++;
                console.log(`[SKIP] Valid cycles: ${this.validCycles}`);
                
                // Save progress before moving to next cycle
                this.saveProgress();
                
                // Update the scorecard preview to reflect the skipped cycle
                this.updateScorecardPreview();
                
                // Move to next cycle
                this.currentCycle++;
                console.log(`[SKIP] New cycle index: ${this.currentCycle}`);
                
                // Update progress bar
                this.updateProgressBar();
                
                // Check if game should end
                if (this.validCycles >= 20 || this.currentCycle >= this.questions.length) {
                    console.log('[SKIP] Game complete - ending game');
                    this.endGame();
                    this.isSkipping = false;
                    return;
                }
                
                // Load the next question
                this.loadQuestion(this.currentCycle);
                
            } catch (error) {
                console.error('[SKIP] Error during skip cycle:', error);
                // Still try to continue to next cycle even if there was an error
                this.saveProgress();
                this.currentCycle++;
                if (this.currentCycle < this.questions.length) {
                    this.loadQuestion(this.currentCycle);
                } else {
                    this.endGame();
                }
            }
            
            // Reset skip flag after a small delay
            setTimeout(() => {
                this.isSkipping = false;
            }, 100);
        },

        // Handle player buzz
        handlePlayerBuzz: function(team, playerIndex, playerName) {
            console.log(`[DEBUG] Player ${playerName} (Team ${team}) buzzed in`);
            
            // Set the current answerer with all required fields
            this.currentAnswerer = { 
                team: parseInt(team, 10), 
                playerIndex: parseInt(playerIndex, 10), 
                playerName: String(playerName)
            };
            
            console.log('[DEBUG] Set currentAnswerer:', this.currentAnswerer);
            
            // Show the scoring modal
            this.showScoringModal();
            
            this.updateNavigationButtons();
            return true;
        },
        
        // Navigate to a specific cycle
        goToCycle: function(cycleIndex) {
            if (cycleIndex < 0 || cycleIndex >= (this.questions ? this.questions.length : this.totalCycles)) {
                console.log('Cannot navigate to cycle', cycleIndex, '- out of bounds');
                return false;
            }
            
            this.currentCycle = cycleIndex;
            this.loadQuestion(this.currentCycle);
            this.updateNavigationButtons();
            return true;
        },
        
        // Update navigation buttons state
        updateNavigationButtons: function() {
            const prevBtn = document.getElementById('prevCycleBtn');
            const nextBtn = document.getElementById('nextCycleBtn');
            const skipBtn = document.getElementById('skipToNextCycleBtn');
            const throwOutBtn = document.getElementById('throwOutTossupBtn');
            const cycleNumberDisplay = document.getElementById('cycleNumberDisplay');
            
            // Update cycle number display
            if (cycleNumberDisplay) {
                cycleNumberDisplay.textContent = this.currentCycle + 1;
            }
            
            // Update previous button state
            if (prevBtn) {
                prevBtn.disabled = this.currentCycle <= 0;
                prevBtn.title = prevBtn.disabled ? 'First cycle' : 'Previous cycle';
            }
            
            // Update next button state
            if (nextBtn) {
                const isLastCycle = this.currentCycle >= this.questions.length - 1;
                nextBtn.disabled = isLastCycle;
                nextBtn.title = isLastCycle ? 'End of game' : 'Next cycle';
                nextBtn.classList.toggle('btn-outline-primary', !isLastCycle);
                nextBtn.classList.toggle('btn-outline-secondary', isLastCycle);
            }
            
            // Update skip button state
            if (skipBtn) {
                skipBtn.title = 'Skip to next cycle (no points)';
                skipBtn.disabled = this.currentCycle >= this.questions.length - 1;
            }
            
            // Update throw out button state
            if (throwOutBtn) {
                const currentCycle = this.getCurrentCycle();
                const hasScoring = currentCycle.tossup?.points !== null || 
                                 currentCycle.tossup?.team1Answered || 
                                 currentCycle.tossup?.team2Answered;
                throwOutBtn.disabled = !hasScoring;
                throwOutBtn.title = hasScoring ? 'Throw out this tossup' : 'No scoring to throw out';
            }
        },
        
        // Go to the previous cycle
        prevCycle: function() {
            if (this.currentCycle > 0) {
                this.goToCycle(this.currentCycle - 1);
            }
        },
        
        // Handle game end (after 20 tossups or tiebreaker)
        endGame: function() {
            console.log(`[Cycle ${this.currentCycle}] endGame called`);
            // Show a message about game completion
            const team1Score = this.calculateTeamTotal(1);
            const team2Score = this.calculateTeamTotal(2);
            
            let message = `Game completed! Final Score:\n`;
            message += `${this.serverData.game.team1}: ${team1Score}\n`;
            message += `${this.serverData.game.team2}: ${team2Score}\n\n`;
            
            // Check if we're out of tossups (assuming 20 tossups + any tiebreakers)
            const isOutOfTossups = this.currentCycle >= this.totalCycles - 1;
            
            if (team1Score > team2Score) {
                message += `${this.serverData.game.team1} wins!`;
            } else if (team2Score > team1Score) {
                message += `${this.serverData.game.team2} wins!`;
            } else if (!isOutOfTossups) {
                // Only continue if we have more tossups available
                message += "It's a tie! The game will continue with the next tossup.";
                
                // Enable continue button for tiebreakers
                const nextCycleBtn = document.getElementById('nextCycleBtn');
                if (nextCycleBtn) {
                    nextCycleBtn.disabled = false;
                    nextCycleBtn.textContent = 'Next Tossup';
                }
                
                // Show the message but don't disable controls
                alert(message);
                return;
            } else {
                // If we're out of tossups and it's still a tie, just show the tie message
                message += "The game has ended in a tie!";
            }
            
            // Disable controls for all buttons except submit/next cycle
            const buttons = document.querySelectorAll('button');
            buttons.forEach(btn => {
                if (btn.id !== 'submitGameBtn' && btn.id !== 'nextCycleBtn') {
                    btn.disabled = true;
                }
            });
            
            // Always submit the game when it ends, whether there's a winner or it's a tie
            this.submitGame();
        },
        
        // Flag to track if we're in the middle of processing a cycle change
        isProcessingCycle: false,
        
        // Move to the next cycle
        nextCycle: function(isCycleValid = true) {
            // Clear the bonus eligible team when moving to next cycle
            this.bonusEligibleTeam = null;
            // Prevent multiple rapid clicks
            if (this.isProcessingCycle) {
                console.log('[CYCLE] Already processing cycle change');
                return;
            }
            
            this.isProcessingCycle = true;
            console.log(`[CYCLE] Starting nextCycle, current cycle: ${this.currentCycle}, valid: ${isCycleValid}`);
            try {
                console.log(`[Cycle ${this.currentCycle + 1}] nextCycle called, isCycleValid: ${isCycleValid}, Current valid cycles: ${this.validCycles}`);
                
                // First, capture the current active players for the cycle
                this.updateActivePlayers();
                
                // Save the current cycle's scores before resetting
                const currentCycle = this.getCurrentCycle();
                if (currentCycle) {
                    // Make sure we have the latest scores
                    this.updateScores();
                    
                    // Store the scores in the cycle data
                    currentCycle.team1Score = this.calculateTeamTotal(1);
                    currentCycle.team2Score = this.calculateTeamTotal(2);
                    
                    // Log the scores for debugging
                    console.log(`[Cycle ${this.currentCycle + 1}] Saving scores - Team 1: ${currentCycle.team1Score}, Team 2: ${currentCycle.team2Score}`);
                }
                
                // Reset answer tracking state
                this.currentAnswerer = null;
                this.hasTeam1Answered = false;
                this.hasTeam2Answered = false;
                this.currentWordIndex = 0;
                
                // Reset any active player selections
                this.resetActiveSelections();
                
                // Close any open modals
                const modal = bootstrap.Modal.getInstance(document.getElementById('scoringModal'));
                if (modal) {
                    modal.hide();
                }
                
                // If this is a valid cycle, increment the counter
                if (isCycleValid) {
                    this.validCycles++;
                    console.log(`[Cycle ${this.currentCycle + 1}] Marked as valid, total valid cycles: ${this.validCycles}`);
                }
                
                // Only process the current cycle if it exists and is valid
                if (isCycleValid && this.scorecard.cycles[this.currentCycle]) {
                    const currentCycle = this.scorecard.cycles[this.currentCycle];
                    
                    // Ensure bonus is properly initialized
                    if (!currentCycle.bonus) {
                        currentCycle.bonus = { 
                            team1: 0, 
                            team2: 0, 
                            parts: [0, 0, 0] 
                        };
                    } else if (Array.isArray(currentCycle.bonus)) {
                        // Convert old array format to new object format
                        currentCycle.bonus = { 
                            team1: currentCycle.bonus.reduce((sum, p) => sum + (parseInt(p) || 0), 0),
                            team2: 0,
                            parts: currentCycle.bonus.map(p => parseInt(p) || 0)
                        };
                    }
                    
                    // Calculate total bonus points for the cycle
                    const teamWithBonus = currentCycle.bonus.team1 > 0 ? 1 : 
                                       (currentCycle.bonus.team2 > 0 ? 2 : 0);
                    const totalBonus = teamWithBonus > 0 ? currentCycle.bonus[`team${teamWithBonus}`] : 0;
                    
                    // Store the total bonus in the cycle data
                    currentCycle.bonusTotal = totalBonus;
                    
                    // Log for debugging
                    console.log('Current cycle:', currentCycle);
                    console.log(`Cycle ${this.currentCycle + 1} bonus total: ${totalBonus} points for team ${teamWithBonus}`);
                    
                    // Reset the answered flags for the next cycle
                    if (currentCycle.tossup) {
                        currentCycle.tossup.team1Answered = false;
                        currentCycle.tossup.team2Answered = false;
                    }
                }

                // Check if we've reached 20 valid cycles before moving to next cycle
                if (this.validCycles >= 20 && !this.isTiebreaker) {
                    const team1Score = this.calculateTeamTotal(1);
                    const team2Score = this.calculateTeamTotal(2);
                    
                    console.log(`[Cycle ${this.currentCycle + 1}] Checking end game conditions - Team 1: ${team1Score}, Team 2: ${team2Score}, Valid Cycles: ${this.validCycles}`);
                    
                    if (team1Score !== team2Score) {
                        console.log(`[Cycle ${this.currentCycle + 1}] Game complete: 20+ valid cycles with different scores`);
                        this.endGame();
                        return;
                    } else if (this.validCycles > 20) {
                        this.isTiebreaker = true;
                        console.log(`[Cycle ${this.currentCycle + 1}] Entering tiebreaker mode after ${this.validCycles} valid cycles`);
                        this.showMessage("Scores are tied after 20 questions. Game will continue until one team scores.");
                    }
                }
                
                // Move to the next cycle
                const previousCycle = this.currentCycle;
                this.currentCycle++;
                console.log(`[Cycle ${previousCycle + 1}  ${this.currentCycle + 1}] Moving to next cycle, validCycles: ${this.validCycles}`);
                
                // Initialize the new cycle with default values if we haven't reached the end
                if (this.currentCycle < (this.questions ? this.questions.length : this.totalCycles)) {
                    this.initializeCycle(this.currentCycle);
                } else {
                    console.log(`[Cycle ${this.currentCycle + 1}] Reached maximum number of cycles, validCycles: ${this.validCycles}`);
                    
                    // If we've run out of cycles but haven't reached 20 valid cycles, continue
                    if (this.validCycles < 20) {
                        console.log(`[Cycle ${this.currentCycle + 1}] Continuing until 20 valid cycles are reached`);
                    } else {
                        // If we've reached 20 valid cycles and run out of questions, end the game
                        const team1Score = this.calculateTeamTotal(1);
                        const team2Score = this.calculateTeamTotal(2);
                        
                        if (team1Score !== team2Score) {
                            console.log(`[Cycle ${this.currentCycle + 1}] Game complete: No more questions after ${this.validCycles} valid cycles`);
                            this.endGame();
                            return;
                        } else {
                            this.isTiebreaker = true;
                            console.log(`[Cycle ${this.currentCycle + 1}] Entering tiebreaker mode after running out of questions`);
                            this.showMessage("Scores are tied after all questions. Game will continue until one team scores.");
                        }
                    }
                }
                
                // Update active players for the new cycle based on current checkbox state
                this.updateActivePlayers();
                
                // Update the player selection UI to reflect the new cycle's active players
                this.updatePlayerSelectionUI();

                // Log the scorecard after updating the cycle
                console.log('--- Scorecard after cycle', this.currentCycle, '---');
                console.log(JSON.stringify(this.scorecard, null, 2));
                
                // Update scores to ensure UI is in sync
                this.updateScores();
                
                // Save progress silently
                this.saveProgress(true);
                
                // Update navigation buttons
                this.updateNavigationButtons();
                
                // Log the calculated scores for verification
                console.log('--- Current Scores ---');
                console.log('Team 1 Tossups:', this.calculateTeamTotal(1) - this.calculateTeamBonusTotal(1));
                console.log('Team 1 Bonuses:', this.calculateTeamBonusTotal(1));
                console.log('Team 1 Total:', this.calculateTeamTotal(1));
                console.log('Team 2 Tossups:', this.calculateTeamTotal(2) - this.calculateTeamBonusTotal(2));
                console.log('Team 2 Bonuses:', this.calculateTeamBonusTotal(2));
                console.log('Team 2 Total:', this.calculateTeamTotal(2));
                
                // Hide and clean up bonus section
                const bonusSection = document.getElementById('bonusSection');
                if (bonusSection) {
                    bonusSection.style.display = 'none';
                    // Clear any bonus UI elements
                    const bonusContainer = document.getElementById('bonusQuestions');
                    if (bonusContainer) {
                        bonusContainer.innerHTML = '';
                    }
                }
                
                // Reset any bonus-related state
                if (this.scorecard.cycles[this.currentCycle]) {
                    const currentCycle = this.scorecard.cycles[this.currentCycle];
                    if (currentCycle.bonus) {
                        currentCycle.bonus.team1 = 0;
                        currentCycle.bonus.team2 = 0;
                        currentCycle.bonus.parts = [0, 0, 0];
                    }
                }
                
                // Check if we should continue to the next question
                const hasMoreQuestions = (this.questions && this.currentCycle < this.questions.length) || 
                                      (!this.questions && this.currentCycle < this.totalCycles);
                
                if (this.validCycles >= 20) {
                    // If we've completed 20+ valid cycles, check for a winner
                    const team1Score = this.calculateTeamTotal(1);
                    const team2Score = this.calculateTeamTotal(2);
                    
                    if (team1Score !== team2Score) {
                        console.log(`[Cycle ${this.currentCycle}] Game complete: 20+ valid cycles with a winner`);
                        this.endGame();
                        return;
                    } else if (hasMoreQuestions) {
                        // If tied after 20 valid cycles, enter tiebreaker mode
                        this.isTiebreaker = true;
                        console.log(`[Cycle ${this.currentCycle}] Entering tiebreaker mode after 20 valid cycles`);
                        this.showMessage("Scores are tied after 20 questions. Game will continue until one team scores.");
                        this.loadQuestion(this.currentCycle);
                    } else {
                        // No more questions and still tied after 20 valid cycles
                        console.log(`[Cycle ${this.currentCycle}] Game tied after 20 valid cycles with no more questions`);
                        this.showMessage('The game has ended in a tie. Submitting results...');
                        this.submitGame();
                        return;
                    }
                } else if (hasMoreQuestions) {
                    // Continue to next question if we haven't reached 20 valid cycles yet
                    console.log(`[Cycle ${this.currentCycle}] Loading next question, validCycles: ${this.validCycles}`);
                    this.loadQuestion(this.currentCycle);
                } else {
                    // No more questions but haven't reached 20 valid cycles
                    console.log(`[Cycle ${this.currentCycle}] Out of questions with only ${this.validCycles} valid cycles`);
                    this.showMessage('Game ended early - not enough valid cycles completed.');
                    this.endGame();
                    return;
                }
                
                // Update the progress bar based on valid cycles (max 20)
                const progressPercentage = Math.min(100, (Math.min(this.validCycles, 20) / 20) * 100);
                const progressBar = document.getElementById('progressBar');
                if (progressBar) {
                    progressBar.style.width = progressPercentage + '%';
                    progressBar.setAttribute('aria-valuenow', progressPercentage);
                    progressBar.setAttribute('aria-valuetext', `${this.validCycles} of 20 valid cycles completed`);
                }
                
                // Update the scorecard preview
                this.updateScorecardPreview();
                
                console.log(`[CYCLE] Moved to cycle index ${this.currentCycle}. Valid cycles: ${this.validCycles}`);
            } catch (error) {
                console.error('[CYCLE] Error in nextCycle:', error);
            } finally {
                // Always reset the processing flag
                this.isProcessingCycle = false;
            }
        },
        
        // Load the current question based on the current cycle
        loadCurrentQuestion: function() {
            this.loadQuestion(this.currentCycle);
            
            // End marker is now added in loadQuestion to ensure it's always processed with the text
        },
        
        // Show or hide the completed question overlay
        updateCompletedQuestionOverlay: function(cycle) {
            const overlay = document.getElementById('completedQuestionOverlay');
            if (!overlay) return;
            
            // Show overlay if there's any tossup scoring
            if (cycle?.tossup?.points !== null && cycle?.tossup?.points !== undefined) {
                overlay.classList.remove('d-none');
            } else {
                overlay.classList.add('d-none');
            }
        },
        
        // Clear the current cycle's scoring
        clearCurrentCycle: function() {
            const cycleIndex = this.currentCycle;
            const cycle = this.getCurrentCycle();
            if (!cycle) return;
            
            console.log(`[CLEAR] Clearing cycle ${cycleIndex}`);
            
            // Reset tossup and bonus data
            if (cycle.tossup) {
                cycle.tossup.points = null;
                cycle.tossup.team1Answered = false;
                cycle.tossup.team2Answered = false;
                cycle.tossup.playerId = null;
                cycle.tossup.playerName = null;
            }
            
            if (cycle.bonus) {
                cycle.bonus.points = null;
                cycle.bonus.team1Answered = false;
                cycle.bonus.team2Answered = false;
            }
            
            // Mark the cycle as invalid in the scorecard
            this.scorecard.cycles[cycleIndex] = {
                ...this.scorecard.cycles[cycleIndex],
                valid: false
            };
            
            // Hide the overlay
            const overlay = document.getElementById('completedQuestionOverlay');
            if (overlay) {
                overlay.classList.add('d-none');
            }
            
            console.log(`[CLEAR] Cycle ${cycleIndex} cleared and marked as invalid`);
            
            // Force update all UI elements
            this.updateScores();
            this.updateProgress();
            this.updateUI();
            this.updateScorecardPreview();
            
            // Save the updated state
            this.saveProgress();
            
            console.log('[CLEAR] UI and scores updated');
        },
        
        // Load a specific question
        loadQuestion: function(index) {
            console.log(`[LOAD] Loading question at index: ${index}`);
            
            // Validate index
            if (index < 0 || index >= this.questions.length) {
                console.error(`[LOAD] Invalid question index: ${index}`);
                return;
            }
            
            // Hide bonus section initially, will be shown if needed
            const bonusSection = document.getElementById('bonusSection');
            if (bonusSection) bonusSection.style.display = 'none';
            
            // Get or initialize cycle data
            let cycle = this.scorecard.cycles[index];
            const isNewCycle = !cycle;
            
            // Update the completed question overlay
            this.updateCompletedQuestionOverlay(cycle);
            
            if (isNewCycle) {
                console.log(`[LOAD] Initializing new cycle ${index}`);
                this.scorecard.cycles[index] = {
                    tossup: { 
                        points: null, 
                        team: null, 
                        player: null,
                        playerIndex: null,
                        team1Answered: false,
                        team2Answered: false
                    },
                    bonus: { team1: 0, team2: 0, parts: [null, null, null] },
                    scores: [[], [], [], []]
                };
                cycle = this.scorecard.cycles[index];
            } else {
                console.log(`[LOAD] Restoring existing cycle ${index}`, JSON.parse(JSON.stringify(cycle)));
                
                // Restore bonus state if it exists
                if (cycle.bonus) {
                    // Show bonus section if either team has bonus points
                    if ((cycle.bonus.team1 && cycle.bonus.team1 > 0) || 
                        (cycle.bonus.team2 && cycle.bonus.team2 > 0) ||
                        (cycle.bonus.parts && cycle.bonus.parts.some(part => part !== null))) {
                        if (bonusSection) bonusSection.style.display = 'block';
                    }
                }
                
                // Restore team answer states
                if (cycle.tossup) {
                    this.hasTeam1Answered = cycle.tossup.team1Answered || false;
                    this.hasTeam2Answered = cycle.tossup.team2Answered || false;
                }
            }
            
            // Update current cycle index
            this.currentCycle = index;
            console.log(`[LOAD] Set currentCycle to ${this.currentCycle}`);
            
            // Reset answer tracking
            this.currentAnswerer = null;
            
            // Only reset answer states for new cycles or if not already set
            if (!cycle.tossup) {
                this.hasTeam1Answered = false;
                this.hasTeam2Answered = false;
            } else {
                // Restore answer states from saved cycle
                this.hasTeam1Answered = cycle.tossup.team1Answered || false;
                this.hasTeam2Answered = cycle.tossup.team2Answered || false;
                
                // Restore current answerer if any
                if (cycle.tossup.player) {
                    this.currentAnswerer = {
                        team: cycle.tossup.team,
                        player: cycle.tossup.player,
                        playerIndex: cycle.tossup.playerIndex
                    };
                }
            }
            
            // Get the current question
            const question = this.questions[index];
            const questionContainer = document.getElementById('tossupQuestion');
            
            if (!questionContainer) {
                console.error('Question container not found');
                return;
            }
            
            // Update question text with clickable words
            const questionText = questionContainer.querySelector('.question-text');
            if (questionText) {
                try {
                    // Clear previous content
                    questionText.innerHTML = '';
                    
                    // Process question text to handle HTML tags and make words clickable
                    let text = question.question_text || 'No question text available';
                    
                    // Ensure the end marker is present
                    if (!text.includes('///')) {
                        text += ' ///';
                        // Update the question text in the data model
                        question.question_text = text;
                    }
                    
                    console.log('Processing question text:', text);
                    
                    // First, split by HTML tags to preserve them
                    const tagRegex = /(<\/?[a-z][^>]*>|\s+|[^<\s]+)/gi;
                    const tokens = text.match(tagRegex) || [];
                    
                    tokens.forEach(token => {
                        if (!token.trim() && token !== ' ') {
                            return;
                        }
                        
                        // Check if it's an HTML tag
                        if (token.startsWith('<') && token.endsWith('>')) {
                            try {
                                // Create a temporary container to parse the HTML
                                const temp = document.createElement('div');
                                temp.innerHTML = token;
                                // Only append if we have a valid node
                                if (temp.firstChild) {
                                    questionText.appendChild(temp.firstChild);
                                }
                            } catch (e) {
                                console.error('Error processing HTML tag:', token, e);
                                questionText.appendChild(document.createTextNode(token));
                            }
                            return;
                        }
                        
                        // Handle regular text (split into words)
                        if (token.trim() === '') {
                            questionText.appendChild(document.createTextNode(token));
                            return;
                        }
                        
                        // Create clickable word span
                        const span = document.createElement('span');
                        span.className = 'clickable-word';
                        span.style.cursor = 'pointer';
                        span.style.display = 'inline-block';
                        span.style.margin = '0 1px';
                        span.style.padding = '2px 0';
                        span.style.borderRadius = '3px';
                        span.style.transition = 'background-color 0.2s';
                        
                        // Set text content instead of innerHTML to prevent XSS
                        span.textContent = token;
                        
                        // Add hover effect
                        span.addEventListener('mouseover', (e) => {
                            e.target.style.backgroundColor = '#e9ecef';
                        });
                        
                        span.addEventListener('mouseout', (e) => {
                            e.target.style.backgroundColor = '';
                        });
                        
                        // Add click handler to open scoring modal
                        const wordIndex = Array.from(questionText.querySelectorAll('.clickable-word')).length;
                        span.dataset.wordIndex = wordIndex;
                        
                        span.addEventListener('click', (e) => {
                            e.stopPropagation();
                            const clickedWord = e.target.textContent.trim();
                            const wordIndex = parseInt(e.target.dataset.wordIndex, 10);
                            console.log('Word clicked:', clickedWord, 'at index:', wordIndex);
                            this.openScoringModal(e.target, clickedWord, wordIndex);
                        });
                        
                        questionText.appendChild(span);
                    });
                } catch (error) {
                    console.error('Error processing question text:', error);
                    questionText.textContent = 'Error loading question text. Please try again.';
                }
                
                // Add answer line if available
                if (question.answer) {
                    const answerLine = document.createElement('div');
                    answerLine.className = 'answerline mt-3 p-2 bg-light rounded';
                    answerLine.innerHTML = `<strong>ANSWER:</strong> ${question.answer}`;
                    questionText.appendChild(answerLine);
                }
            }
            
            // Update question number display
            const questionNumber = document.getElementById('currentQuestionNumber');
            if (questionNumber) {
                questionNumber.textContent = `#${index + 1}`;
            }
            
            // Update active question in menu
            this.updateActiveQuestionMenu(index);
            
            // Do not preload bonus; it will be loaded if the team earns it (10/15)
            // this.loadBonus(index);
            
            // Update UI
            this.updateUI();
            this.updateProgress();
        },
        
        // Update active question in menu
        updateActiveQuestionMenu: function(activeIndex) {
            const menuItems = document.querySelectorAll('#questionsMenu button');
            menuItems.forEach((item, index) => {
                if (index === activeIndex) {
                    item.classList.add('bg-blue-600', 'text-white');
                    item.classList.remove('bg-gray-100', 'hover:bg-gray-200');
                } else {
                    item.classList.remove('bg-blue-600', 'text-white');
                    item.classList.add('bg-gray-100', 'hover:bg-gray-200');
                }
            });
        },
        
        // Initialize the questions menu
        initializeQuestionsMenu: function() {
            const menu = document.getElementById('questionsMenu');
            if (!menu) return;
            
            // Clear existing menu items
            menu.innerHTML = '';
            
            // Add menu items for each question
            for (let i = 0; i < this.questions.length; i++) {
                const button = document.createElement('button');
                button.type = 'button';
                button.className = 'px-3 py-2 rounded-md text-sm font-medium';
                button.textContent = i + 1;
                button.dataset.index = i;
                
                // Set active state for first question
                if (i === 0) {
                    button.classList.add('bg-blue-600', 'text-white');
                } else {
                    button.classList.add('bg-gray-100', 'hover:bg-gray-200');
                }
                
                // Add click handler
                button.addEventListener('click', (e) => {
                    const index = parseInt(e.target.dataset.index);
                    this.loadQuestion(index);
                });
                
                menu.appendChild(button);
            }
        },
        
        // Load bonus for a question
        loadBonus: function(questionIndex) {
            console.log('=== DEBUG: Loading bonus ===');
            console.log('Question index:', questionIndex);
            console.log('All bonuses:', JSON.stringify(this.bonuses, null, 2));
            
            // Try to find bonus by array index first (0-based)
            let bonus = this.bonuses[questionIndex];
            
            // If not found by index, try to find by question_number (1-based)
            if (!bonus && this.bonuses.length > 0) {
                // Try direct match first
                bonus = this.bonuses.find(b => b.question_number === (questionIndex + 1));
                
                // If still not found, try to find any bonus with a matching question_number
                if (!bonus) {
                    console.log('No direct match, trying to find any bonus...');
                    bonus = this.bonuses[0]; // Just take the first bonus for now
                }
            }
            
            if (!bonus) {
                console.error('No bonus found for question index:', questionIndex);
                console.error('Available bonus question_numbers:', this.bonuses.map(b => b.question_number));
                return;
            }
            
            console.log('Found bonus:', bonus);
            
            // If we have a bonus but no parts, try to use the question_text as the lead-in
            if (bonus && (!bonus.parts || bonus.parts.length === 0) && bonus.question_text) {
                console.log('Using question_text as bonus lead-in');
                bonus.parts = [bonus.question_text];
                bonus.answers = [bonus.answer || 'No answer available'];
            }
            
            let bonusHtml = '';
            
            try {
                // Generate HTML for each bonus part
                const parts = bonus.parts || [];
                const answers = bonus.answers || [];
                
                // Add bonus lead-in (if available in the first part)
                if (bonus.leadin || bonus.question_text) {
                    bonusHtml += `
                        <div class="bonus-leadin mb-4 p-3 bg-light rounded">
                            <h5>Bonus Question ${bonus.question_number}</h5>
                            <p class="mb-0">${bonus.leadin || bonus.question_text}</p>
                        </div>`;
                }
                
                // Generate parts
                for (let i = 0; i < 3; i++) {
                    const partNum = i + 1;
                    const partText = parts[i] || 'No bonus part text available';
                    const answerText = answers[i] || 'No answer available';
                    
                    bonusHtml += `
                        <div class="bonus-part mb-3 p-3 bg-light rounded">
                            <h6>Part ${partNum} (10 points)</h6>
                            <p>${partText}</p>
                            <p class="text-muted">ANSWER: ${answerText}</p>
                            <div class="btn-group" role="group">
                                <button type="button" class="btn btn-outline-success bonus-btn" data-part="${partNum}" data-points="10">Correct</button>
                                <button type="button" class="btn btn-outline-danger bonus-btn active" data-part="${partNum}" data-points="0">Incorrect</button>
                            </div>
                            <span class="ms-2 bonus-score">(0 pts)</span>
                        </div>
                    `;
                }
            } catch (error) {
                console.error('Error generating bonus HTML:', error);
                return;
            }
            
            // Update the bonus section
            const bonusContainer = document.getElementById('bonusQuestions');
            if (bonusContainer) {
                bonusContainer.innerHTML = bonusHtml;
                
                // Set up event listeners for the new bonus buttons
                document.querySelectorAll('.bonus-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => this.handleBonusPoints(e));
                });
            }
            
            // Show bonus section
            const bonusSection = document.getElementById('bonusSection');
            if (bonusSection) {
                bonusSection.style.display = 'block';
                
                // Initialize all bonus parts as incorrect (0 points) in the scorecard
                if (this.scorecard.cycles[this.currentCycle]) {
                    // Ensure bonus structure exists
                    if (!this.scorecard.cycles[this.currentCycle].bonus) {
                        this.scorecard.cycles[this.currentCycle].bonus = { 
                            team1: 0, 
                            team2: 0, 
                            parts: [0, 0, 0] // Initialize all parts as incorrect (0 points)
                        };
                    } else if (!Array.isArray(this.scorecard.cycles[this.currentCycle].bonus.parts)) {
                        this.scorecard.cycles[this.currentCycle].bonus.parts = [0, 0, 0];
                    }
                    
                    // Mark all parts as completed with 0 points
                    this.scorecard.cycles[this.currentCycle].bonus.parts = this.scorecard.cycles[this.currentCycle].bonus.parts.map(() => 0);
                    
                    // Update the total bonus points
                    const teamNum = this.bonusEligibleTeam || 1;
                    this.scorecard.cycles[this.currentCycle].bonus[`team${teamNum}`] = 0;
                    
                    // Update the UI
                    this.updateScores();
                    this.updateScorecardPreview();
                }
            }
        },
        
        // Helper function to format score with color
        formatScore: function(score) {
            if (score === 0) return '';
            const scoreClass = score > 0 ? 'text-success' : 'text-danger';
            return '<span class="' + scoreClass + '">' + (score > 0 ? '+' + score : score) + '</span>';
        },
        
        // Helper function to get all attempts for a team in a cycle
        getTeamAttempts: function(cycle, teamNum) {
            const teamIndex = teamNum === 1 ? 0 : 2;
            const players = teamNum === 1 ? 
                (this.serverData.playersTeam1 || []) : 
                (this.serverData.playersTeam2 || []);
            const activePlayers = teamNum === 1 ? 
                (cycle.team1Players || Array(players.length).fill(1)) :
                (cycle.team2Players || Array(players.length).fill(1));
            const attempts = [];
            
            if (!cycle.scores || !cycle.scores[teamIndex]) {
                // If no scores but we have active status, include N/A for inactive players
                return players.map((player, index) => ({
                    player,
                    points: activePlayers[index] === false ? 'N/A' : 0
                }));
            }
            
            // Include all players, with their score or N/A if inactive
            return players.map((player, index) => {
                const points = cycle.scores[teamIndex][index];
                const isActive = activePlayers[index] !== false; // Default to true if not set
                
                return {
                    player,
                    points: !isActive ? 'N/A' : (points !== undefined ? points : 0)
                };
            });
        },
        
        // Update the scorecard preview
        updateScorecardPreview: function() {
            console.log('Updating scorecard preview...');
            const preview = document.getElementById('scorecardPreview');
            if (!preview) {
                console.warn('Scorecard preview element not found');
                return;
            }
            
            // Always update the scorecard since it's always visible now
            this.scorecardState.lastUpdate = new Date();
            
            try {
                // Get all unique player keys from both teams across all cycles
                const allPlayerKeys = new Set();
                const team1Players = this.serverData.playersTeam1 || [];
                const team2Players = this.serverData.playersTeam2 || [];
                
                // Add all player keys from both teams
                team1Players.forEach(player => {
                    const playerKey = typeof player === 'object' ? player.id || player.name : player;
                    allPlayerKeys.add(`team1_${playerKey}`);
                });
                team2Players.forEach(player => {
                    const playerKey = typeof player === 'object' ? player.id || player.name : player;
                    allPlayerKeys.add(`team2_${playerKey}`);
                });
                
                // Create a map from player keys to display names
                const playerKeyToName = {};
                team1Players.forEach(player => {
                    const playerKey = `team1_${typeof player === 'object' ? player.id || player.name : player}`;
                    playerKeyToName[playerKey] = typeof player === 'object' ? player.name : player;
                });
                team2Players.forEach(player => {
                    const playerKey = `team2_${typeof player === 'object' ? player.id || player.name : player}`;
                    playerKeyToName[playerKey] = typeof player === 'object' ? player.name : player;
                });
                
                // Sort player keys for consistent display
                const sortedPlayerKeys = Array.from(allPlayerKeys).sort((a, b) => {
                    // Team 1 players first, then team 2
                    const teamA = a.startsWith('team1_') ? 0 : 1;
                    const teamB = b.startsWith('team1_') ? 0 : 1;
                    if (teamA !== teamB) return teamA - teamB;
                    // Then sort by player name within team
                    return playerKeyToName[a].localeCompare(playerKeyToName[b]);
                });
                
                // Group player keys by team
                const team1PlayerKeys = sortedPlayerKeys.filter(key => key.startsWith('team1_'));
                const team2PlayerKeys = sortedPlayerKeys.filter(key => key.startsWith('team2_'));
                
                let html = '<div class="table-responsive"><table class="table table-sm table-bordered">';
                
                // Build table header
                html += '<thead class="table-light"><tr>';
                html += '<th rowspan="2">#</th>';
                
                // Add team headers with dynamic column spans
                if (team1PlayerKeys.length > 0) {
                    html += `<th colspan="${team1PlayerKeys.length + 1}" class="text-center">${this.serverData.game.team1 || 'Team 1'}</th>`;
                }
                if (team2PlayerKeys.length > 0) {
                    html += `<th colspan="${team2PlayerKeys.length + 1}" class="text-center">${this.serverData.game.team2 || 'Team 2'}</th>`;
                }
                
                html += '</tr><tr>';
                
                // Add player names for team 1
                team1PlayerKeys.forEach(playerKey => {
                    const playerName = playerKeyToName[playerKey];
                    html += `<th class="small">${playerName}</th>`;
                });
                if (team1PlayerKeys.length > 0) {
                    html += '<th>Bonus</th>';
                }
                
                // Add player names for team 2
                team2PlayerKeys.forEach(playerKey => {
                    const playerName = playerKeyToName[playerKey];
                    html += `<th class="small">${playerName}</th>`;
                });
                if (team2PlayerKeys.length > 0) {
                    html += '<th>Bonus</th>';
                }
                
                html += '</tr></thead><tbody>';
                
                // Add rows for each cycle
                let validCycleCounter = 0;
                this.scorecard.cycles.forEach((cycle, index) => {
                    if (cycle.isThrownOut) return; // Skip thrown out cycles
                    
                    validCycleCounter++;
                    const cycleDisplay = validCycleCounter;
                    
                    // Get the cleaned cycle data to match the format used in download
                    const cycleData = {
                        team1: { ...(cycle.team1 || {}) },
                        team2: { ...(cycle.team2 || {}) },
                        team1Bonus: cycle.team1Bonus,
                        team2Bonus: cycle.team2Bonus,
                        buzzes: { ...(cycle.buzzes || {}) },
                        words: cycle.words || []
                    };
                    
                    html += '<tr>';
                    html += `<th>${cycleDisplay}</th>`;
                    
                    // Process team 1 players
                    team1PlayerKeys.forEach(playerKey => {
                        const playerId = playerKey.replace('team1_', '');
                        const playerScores = cycleData.team1[playerId];
                        
                        if (playerScores !== undefined && playerScores !== null && playerScores.length > 0) {
                            // Player has scores, show the first one (or sum if multiple?)
                            const score = Array.isArray(playerScores) ? playerScores[0] : playerScores;
                            if (score === 0) {
                                html += '<td class="text-center">0</td>';
                            } else if (score !== undefined && score !== null) {
                                html += `<td class="text-center">${this.formatScore(score)}</td>`;
                            } else {
                                html += '<td class="text-center text-muted">--</td>';
                            }
                        } else {
                            // Player has no score for this cycle
                            html += '<td class="text-center text-muted">--</td>';
                        }
                    });
                    
                    // Team 1 bonus
                    if (team1PlayerKeys.length > 0) {
                        const team1Bonus = cycleData.team1Bonus;
                        if (team1Bonus === 0) {
                            html += '<td class="text-center">0</td>';
                        } else if (team1Bonus !== undefined && team1Bonus !== null) {
                            html += `<td class="text-center text-success fw-bold">${team1Bonus}</td>`;
                        } else {
                            html += '<td class="text-center text-muted">--</td>';
                        }
                    }
                    
                    // Process team 2 players
                    team2PlayerKeys.forEach(playerKey => {
                        const playerId = playerKey.replace('team2_', '');
                        const playerScores = cycleData.team2[playerId];
                        
                        if (playerScores !== undefined && playerScores !== null && playerScores.length > 0) {
                            // Player has scores, show the first one (or sum if multiple?)
                            const score = Array.isArray(playerScores) ? playerScores[0] : playerScores;
                            if (score === 0) {
                                html += '<td class="text-center">0</td>';
                            } else if (score !== undefined && score !== null) {
                                html += `<td class="text-center">${this.formatScore(score)}</td>`;
                            } else {
                                html += '<td class="text-center text-muted">--</td>';
                            }
                        } else {
                            // Player has no score for this cycle
                            html += '<td class="text-center text-muted">--</td>';
                        }
                    });
                    
                    // Team 2 bonus
                    if (team2PlayerKeys.length > 0) {
                        const team2Bonus = cycleData.team2Bonus;
                        if (team2Bonus === 0) {
                            html += '<td class="text-center">0</td>';
                        } else if (team2Bonus !== undefined && team2Bonus !== null) {
                            html += `<td class="text-center text-success fw-bold">${team2Bonus}</td>`;
                        } else {
                            html += '<td class="text-center text-muted">--</td>';
                        }
                    }
                    
                    html += '</tr>';
                }, this);
                
                // Add totals row
                html += '<tr class="table-active fw-bold">';
                html += '<th>Total</th>';
                
                // Team 1 player totals
                const team1PlayerTotals = this.calculatePlayerTotals(1);
                team1PlayerTotals.forEach(function(total) {
                    html += '<td class="text-center">' + (total >= 0 ? '+' + total : total) + '</td>';
                });
                
                // Team 1 bonus total
                const team1BonusTotal = this.calculateTeamBonusTotal(1);
                html += '<td class="text-center">' + team1BonusTotal + '</td>';
                
                // Team 2 player totals
                const team2PlayerTotals = this.calculatePlayerTotals(2);
                team2PlayerTotals.forEach(function(total) {
                    html += '<td class="text-center">' + (total >= 0 ? '+' + total : total) + '</td>';
                });
                
                // Team 2 bonus total
                const team2BonusTotal = this.calculateTeamBonusTotal(2);
                html += '<td class="text-center">' + team2BonusTotal + '</td>';
                
                html += '</tr>';
                
                // Close the table
                html += '</tbody></table></div>';
                
                // Update the preview
                preview.innerHTML = html;
                
            } catch (error) {
                console.error('Error updating scorecard preview:', error);
                preview.innerHTML = '<div class="alert alert-danger">Error loading scorecard preview</div>';
            }
        },
        
        // Calculate total points for all players on a team
        calculatePlayerTotals: function(teamNum) {
            const teamIndex = teamNum === 1 ? 0 : 2;
            const players = teamNum === 1 ? 
                (this.serverData.playersTeam1 || []) : 
                (this.serverData.playersTeam2 || []);
            const totals = Array(players.length).fill(0);
            
            this.scorecard.cycles.forEach(cycle => {
                if (cycle.scores && cycle.scores[teamIndex]) {
                    cycle.scores[teamIndex].forEach((points, index) => {
                        if (index < totals.length && points !== null && points !== undefined) {
                            totals[index] += points;
                        }
                    });
                }
            });
            
            return totals;
        },
        
        // Calculate bonus total for a team
        calculateTeamBonusTotal: function(teamNum) {
            const bonusIndex = teamNum === 1 ? 1 : 3;
            let total = 0;
            const teamKey = 'team' + teamNum;
            
            this.scorecard.cycles.forEach(cycle => {
                // First check the bonus object (new format)
                if (cycle.bonus && cycle.bonus[teamKey] !== undefined) {
                    const points = parseInt(cycle.bonus[teamKey]);
                    if (!isNaN(points)) {
                        total += points;
                        return; // Skip the rest of this cycle if we found points in the bonus object
                    }
                }
                
                // Fall back to the scores array (legacy format)
                if (cycle.scores && cycle.scores[bonusIndex] !== null && cycle.scores[bonusIndex] !== undefined) {
                    const points = parseInt(cycle.scores[bonusIndex]);
                    if (!isNaN(points)) {
                        total += points;
                    }
                }
            });
            
            return total;
        },
        
        // Calculate a single player's total points
        calculatePlayerTotal: function(teamNum, playerIndex) {
            let total = 0;
            const tossupIndex = teamNum === 1 ? 0 : 2; // 0 for team1 tossups, 2 for team2 tossups
            
            this.scorecard.cycles.forEach(cycle => {
                if (cycle.scores && cycle.scores[tossupIndex] && cycle.scores[tossupIndex][playerIndex] !== undefined) {
                    const points = cycle.scores[tossupIndex][playerIndex];
                    if (points !== null && points !== undefined) {
                        total += points;
                    }
                }
            });
            
            return total;
        },
        
        // Calculate team's total points (tossups + bonuses)
        calculateTeamTotal: function(teamNum) {
            let total = 0;
            
            // Add up all player points
            const playerTotals = this.calculatePlayerTotals(teamNum);
            total += playerTotals.reduce((sum, points) => sum + points, 0);
            
            // Add team bonus points
            total += this.calculateTeamBonusTotal(teamNum);
            
            return total;
        },
        
        // Clean cycle data by removing empty/undefined fields and restructuring scores
        cleanCycleData: function(cycle) {
            console.group('cleanCycleData - Input cycle:');
            console.log(JSON.parse(JSON.stringify(cycle)));
            console.groupEnd();
            
            const clean = {
                team1: {},
                team2: {},
                activePlayers: {
                    team1: [],
                    team2: []
                },
                team1Bonus: 0,
                team2Bonus: 0,
                buzzes: {}
            };
            
            // Process team1 players and scores
            if (cycle.team1Players && Array.isArray(cycle.team1Players)) {
                cycle.team1Players.forEach((player, index) => {
                    if (player && player.id) {
                        const playerId = player.id;
                        const points = (cycle.team1Scores && cycle.team1Scores[index]) || 0;
                        
                        // Only include players who were active this cycle
                        if (player.active !== false) {  // Default to true if not specified
                            clean.team1[playerId] = points;
                            clean.activePlayers.team1.push(playerId);
                            console.log(`Team 1 Active Player ${playerId}: ${points} points`);
                        } else {
                            console.log(`Team 1 Inactive Player ${playerId}: Skipping`);
                        }
                    }
                });
            }
            
            // Process team2 players and scores
            if (cycle.team2Players && Array.isArray(cycle.team2Players)) {
                cycle.team2Players.forEach((player, index) => {
                    if (player && player.id) {
                        const playerId = player.id;
                        const points = (cycle.team2Scores && cycle.team2Scores[index]) || 0;
                        
                        // Only include players who were active this cycle
                        if (player.active !== false) {  // Default to true if not specified
                            clean.team2[playerId] = points;
                            clean.activePlayers.team2.push(playerId);
                            console.log(`Team 2 Active Player ${playerId}: ${points} points`);
                        } else {
                            console.log(`Team 2 Inactive Player ${playerId}: Skipping`);
                        }
                    }
                });
            }
            
            // Process bonus points (include even if 0)
            clean.team1Bonus = (cycle.team1Bonus !== undefined) ? cycle.team1Bonus : 
                             (cycle.bonus && cycle.bonus.team1) || 0;
            clean.team2Bonus = (cycle.team2Bonus !== undefined) ? cycle.team2Bonus : 
                             (cycle.bonus && cycle.bonus.team2) || 0;
            
            console.log(`Team 1 Active Players: ${clean.activePlayers.team1.join(', ')}`);
            console.log(`Team 2 Active Players: ${clean.activePlayers.team2.join(', ')}`);
            console.log(`Team 1 Bonus: ${clean.team1Bonus}, Team 2 Bonus: ${clean.team2Bonus}`);
            
            // Process buzzes with active player validation
            if (cycle.buzzes && Array.isArray(cycle.buzzes)) {
                console.log(`Processing ${cycle.buzzes.length} buzzes`);
                
                cycle.buzzes.forEach((buzz, idx) => {
                    if (buzz && buzz.wordIndex !== undefined) {
                        const totalWords = cycle.words?.length || 100;
                        const percentComplete = (buzz.wordIndex / totalWords).toFixed(5);
                        
                        // Include all buzz information
                        clean.buzzes[percentComplete] = {
                            team: buzz.team || (buzz.teamNum || (buzz.teamNum === 0 ? 0 : 1)), // Default to team 1 if not specified
                            playerId: buzz.playerId,
                            playerName: buzz.playerName || `Player ${buzz.playerId}`,
                            isCorrect: !!buzz.isCorrect,
                            points: buzz.points || 0,
                            wordIndex: buzz.wordIndex,
                            timestamp: buzz.timestamp || new Date().toISOString()
                        };
                        
                        console.log(`Buzz ${idx + 1}: Team ${clean.buzzes[percentComplete].team} ` +
                                  `Player ${buzz.playerId} at ${percentComplete}% - ` +
                                  `${buzz.isCorrect ? 'Correct' : 'Incorrect'}`);
                    }
                });
            } else {
                console.warn('No valid buzzes array found in cycle');
            }
            
            // Log the final cleaned cycle data
            console.group('cleanCycleData - Output:');
            console.log(JSON.parse(JSON.stringify(clean)));
            console.groupEnd();
            
            return clean;
        },
        
        // Calculate a single player's total points
        calculatePlayerTotal: function(teamNum, playerIndex) {
            let total = 0;
            const tossupIndex = teamNum === 1 ? 0 : 2; // 0 for team1 tossups, 2 for team2 tossups
            
            this.scorecard.cycles.forEach(cycle => {
                if (cycle.scores && cycle.scores[tossupIndex] && cycle.scores[tossupIndex][playerIndex] !== undefined) {
                    const points = cycle.scores[tossupIndex][playerIndex];
                    if (points !== null && points !== undefined) {
                        total += points;
                    }
                }
            });
            
            return total;
        },
        
        // Download scorecard as JSON file with simplified format
        downloadScorecard: function() {
            try {
                console.group('Generating simplified scorecard...');
                
                // Create an array to hold all cycles
                const cycles = [];
                
                // Log the full scorecard for debugging
                console.log('Full scorecard data:', JSON.parse(JSON.stringify(this.scorecard)));

                // Process each cycle
                for (let cycleIndex = 0; cycleIndex < this.scorecard.cycles.length; cycleIndex++) {
                    const cycle = this.scorecard.cycles[cycleIndex];
                    
                    if (!cycle) {
                        console.log(`Skipping cycle ${cycleIndex} - cycle is null/undefined`);
                        continue;
                    }
                    
                    if (cycle.isThrownOut) {
                        console.log(`Skipping cycle ${cycleIndex} - marked as thrown out`);
                        continue;
                    }

                    console.group(`Processing cycle ${cycleIndex}`);
                    console.log('Raw cycle data:', JSON.parse(JSON.stringify(cycle)));
                    
                    // Prepare cycle data with all possible fields
                    const cycleData = {
                        team1Players: cycle.team1Players || [],
                        team2Players: cycle.team2Players || [],
                        team1Scores: (cycle.team1Scores || (cycle.scores && cycle.scores[0]) || []),
                        team2Scores: (cycle.team2Scores || (cycle.scores && cycle.scores[2]) || []),
                        team1Bonus: (cycle.team1Bonus !== undefined ? cycle.team1Bonus : (cycle.bonus && cycle.bonus.team1) || 0),
                        team2Bonus: (cycle.team2Bonus !== undefined ? cycle.team2Bonus : (cycle.bonus && cycle.bonus.team2) || 0),
                        buzzes: cycle.buzzes || [],
                        words: cycle.words || [],
                        scores: cycle.scores || [] // Keep original scores for debugging
                    };
                    
                    console.log('Prepared cycle data for cleaning:', JSON.parse(JSON.stringify(cycleData)));
                    
                    // Clean the cycle data
                    const cleanedCycle = this.cleanCycleData(cycleData);
                    console.log('Cleaned cycle data:', JSON.parse(JSON.stringify(cleanedCycle)));
                    
                    // Only add the cycle if it has some meaningful data
                    const hasData = Object.keys(cleanedCycle.team1).length > 0 ||
                                  Object.keys(cleanedCycle.team2).length > 0 ||
                                  cleanedCycle.team1Bonus !== 0 ||
                                  cleanedCycle.team2Bonus !== 0 ||
                                  Object.keys(cleanedCycle.buzzes).length > 0;
                    
                    if (hasData) {
                        cycles.push(cleanedCycle);
                        console.log(` Added cycle ${cycleIndex} to export`);
                    } else {
                        console.warn(` Skipping cycle ${cycleIndex} - no valid data found`);
                    }
                    
                    console.groupEnd();
                }

                if (cycles.length === 0) {
                    throw new Error('No valid cycle data found to export');
                }

                // If we only have one cycle, return it directly, otherwise return the array
                const jsonData = cycles.length === 1 ? JSON.stringify(cycles[0], null, 2) : JSON.stringify(cycles, null, 2);
                
                // Log the final data structure
                console.group('Final JSON data structure:');
                console.log(JSON.parse(jsonData));
                console.groupEnd();
                
                // Validate the JSON data
                try {
                    JSON.parse(jsonData); // This will throw if JSON is invalid
                    console.log(' Valid JSON generated');
                } catch (e) {
                    console.error(' Invalid JSON generated:', e);
                    throw new Error('Failed to generate valid JSON: ' + e.message);
                }

                // Create a filename with the team names and date
                const date = new Date().toISOString().split('T')[0];
                const team1Name = (this.serverData?.game?.team1 || 'team1').replace(/[^a-z0-9]/gi, '_').toLowerCase();
                const team2Name = (this.serverData?.game?.team2 || 'team2').replace(/[^a-z0-9]/gi, '_').toLowerCase();
                
                // Create a Blob with the JSON data
                const blob = new Blob([jsonData], { type: 'application/json' });
                
                // Create a download link and trigger the download
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `scorecard_${team1Name}_vs_${team2Name}_${date}.json`;
                
                // Show a success message
                console.log(' Scorecard generated successfully!');
                console.groupEnd(); // Close the main group
                
                // Trigger the download
                document.body.appendChild(a);
                a.click();
                
                // Clean up
                setTimeout(() => {
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url);
                }, 0);
                
                this.showMessage('Scorecard downloaded successfully!');
            } catch (error) {
                console.error(' Error generating scorecard:', error);
                this.showMessage('Error generating scorecard: ' + (error.message || 'Unknown error'));
                
                // Log additional error context
                if (error.stack) {
                    console.error('Error stack:', error.stack);
                }
                
                // Re-throw the error to see it in the console
                throw error;
            }
        },
        
        initScorecardToggle: function() {
            const toggleBtn = document.getElementById('toggleScorecardBtn');
            const closeBtn = document.getElementById('closeScorecard');
            const showBtn = document.getElementById('showScorecardBtn');
            const scorecardSection = document.getElementById('scorecardSection');
            
            if (toggleBtn && showBtn && scorecardSection) {
                // Show scorecard
                const showScorecard = () => {
                    scorecardSection.style.display = 'block';
                    showBtn.style.display = 'none';
                };
                
                // Hide scorecard
                const hideScorecard = () => {
                    scorecardSection.style.display = 'none';
                    showBtn.style.display = 'block';
                };
                
                // Toggle when clicking the toggle button
                toggleBtn.addEventListener('click', showScorecard);
                
                // Close when clicking the close button
                if (closeBtn) {
                    closeBtn.addEventListener('click', hideScorecard);
                }
                
                // Close when clicking outside the scorecard
                document.addEventListener('click', (e) => {
                    if (scorecardSection.style.display === 'block' && 
                        !scorecardSection.contains(e.target) && 
                        e.target !== toggleBtn && 
                        !toggleBtn.contains(e.target)) {
                        hideScorecard();
                    }
                });
                
                // Scorecard is hidden by default
                hideScorecard();
            }
        },
        
        // Initialize scorecard toggle functionality
        initScorecardToggle: function() {
            const toggleButton = document.getElementById('toggleScorecardBtn');
            const scorecardSection = document.getElementById('scorecardSection');
            const showButton = document.getElementById('showScorecardBtn');
            
            if (!toggleButton || !scorecardSection || !showButton) return;
            
            // Toggle button in the scorecard header
            toggleButton.addEventListener('click', () => {
                if (scorecardSection.style.display === 'none') {
                    this.showScorecard();
                } else {
                    this.hideScorecard();
                }
            });
            
            // Show button
            showButton.addEventListener('click', () => {
                this.showScorecard();
            });
            
            // Show the scorecard when it's updated
            const originalUpdateScorecardPreview = this.updateScorecardPreview;
            this.updateScorecardPreview = function() {
                const result = originalUpdateScorecardPreview.apply(this, arguments);
                this.showScorecard();
                return result;
            }.bind(this);
        },
        
        // Initialize add player functionality
        initAddPlayer: function() {
            const addPlayerForm = document.getElementById('addPlayerForm');
            const confirmAddPlayer = document.getElementById('confirmAddPlayer');
            
            if (!confirmAddPlayer) return;
            
            console.log('Add Player button found, adding click event listener');
            confirmAddPlayer.addEventListener('click', async (e) => {
                console.log('Add Player button clicked');
                e.preventDefault(); // Prevent default form submission
                
                const teamSelect = document.getElementById('teamSelect');
                const playerNameInput = document.getElementById('playerName');
                const playerNumberInput = document.getElementById('playerNumber');
                const playerName = playerNameInput ? playerNameInput.value.trim() : '';
                const playerNumber = playerNumberInput ? playerNumberInput.value.trim() : null;
                const teamNum = teamSelect ? teamSelect.value : '';
                
                console.log('Form values:', { teamNum, playerName });
                
                if (!teamSelect || !playerNameInput) {
                    console.error('Required form elements not found');
                    alert('Error: Could not find required form elements');
                    return;
                }
                
                if (!playerName) {
                    alert('Please enter a player name');
                    return;
                }
                
                try {
                    // Show loading state
                    confirmAddPlayer.disabled = true;
                    confirmAddPlayer.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Adding...';
                    
                    // Get form data
                    const gameId = '{{ game.id }}';
                    const teamNumInt = parseInt(teamNum, 10);
                    
                    if (!gameId) {
                        throw new Error('Game ID is missing. Please refresh the page and try again.');
                    }
                    
                    // Log the request
                    console.log('Adding player:', {
                        game_id: gameId,
                        team_num: teamNumInt,
                        player_name: playerName,
                        player_number: playerNumber
                    });
                    
                    // Prepare request data - ensure field names match backend expectations
                    const requestData = {
                        game_id: parseInt(gameId, 10),  // Ensure it's a number
                        team_num: teamNumInt,
                        player_name: playerName
                    };
                    
                    // Only add player_number if it's provided and not empty
                    if (playerNumber) {
                        requestData.player_number = parseInt(playerNumber, 10);
                    }
                    
                    // Get CSRF token from meta tag
                    const csrfToken = document.querySelector('meta[name="csrf-token"]').getAttribute('content');
                    
                    // Make the request
                    const response = await fetch('/reader/api/teams/add_player', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': csrfToken
                        },
                        body: JSON.stringify(requestData)
                    });
                    
                    // Handle response
                    if (!response.ok) {
                        throw new Error('Network response was not ok: ' + response.status);
                    }
                    
                    const result = await response.json();
                    
                    if (result && result.success) {
                        const teamNum = result.team_num;
                        const teamName = result.team_name;
                        const playerName = result.player_name;
                        
                        console.log(`Successfully added player: ${playerName} to team ${teamNum} (${teamName})`);
                        
                        // Close the modal
                        const modal = bootstrap.Modal.getInstance(document.getElementById('addPlayerModal'));
                        if (modal) {
                            modal.hide();
                        }
                        
                        // Instead of manually adding to the DOM, reload the player list from the server
                        // This ensures we have the latest data and all state is consistent
                        const gameId = '{{ game.id }}';
                        
                        // Show loading state
                        const teamContainer = document.getElementById(`team${teamNum}Players`);
                        if (teamContainer) {
                            teamContainer.innerHTML = '<div class="text-center"><div class="spinner-border spinner-border-sm" role="status"></div> Updating player list...</div>';
                        }
                        
                        // Fetch the latest game data including the new player
                        fetch(`/reader/api/game/${gameId}/players`)
                            .then(response => response.json())
                            .then(data => {
                                if (data && data.players) {
                                    // Update the game state with the new player list
                                    gameState.playersTeam1 = data.players.team1 || [];
                                    gameState.playersTeam2 = data.players.team2 || [];
                                    
                                    // Force a UI update
                                    gameState.updatePlayerSelectionUI();
                                    
                                    // Show success message
                                    alert(`Successfully added ${playerName} to ${teamName}`);
                                } else {
                                    throw new Error('Invalid response from server');
                                }
                            })
                            .catch(error => {
                                console.error('Error refreshing player list:', error);
                                // Fallback to page reload if the API call fails
                                window.location.reload();
                            });
                    } else {
                        throw new Error(result.error || 'Failed to add player');
                    }
                } catch (error) {
                    console.error('Error:', error);
                    alert('Error: ' + (error.message || 'Failed to add player'));
                } finally {
                    // Reset button state
                    if (confirmAddPlayer) {
                        confirmAddPlayer.disabled = false;
                        confirmAddPlayer.textContent = 'Add Player';
                    }
                }
            });
            
            // Reset form when modal is hidden
            const addPlayerModal = document.getElementById('addPlayerModal');
            if (addPlayerModal) {
                addPlayerModal.addEventListener('hidden.bs.modal', function () {
                    const addPlayerForm = document.getElementById('addPlayerForm');
                    if (addPlayerForm) {
                        addPlayerForm.reset();
                    }
                });
            }
        },
    
    // Handle bonus points
    handleBonusPoints: function(e) {
        try {
            e.preventDefault();
            e.stopPropagation();
            
            const button = e.target.closest('.bonus-btn');
            if (!button) return;
            
            const points = parseInt(button.dataset.points);
            const part = parseInt(button.dataset.part);
            // Use the team that earned the bonus, default to team 1 if not set (shouldn't happen)
            const teamNum = this.bonusEligibleTeam || 1;
            
            console.log(`Scoring ${points} points for bonus part ${part} for team ${teamNum}`);
            
            // Ensure the current cycle exists
            if (!this.scorecard.cycles[this.currentCycle]) {
                this.scorecard.cycles[this.currentCycle] = {
                    tossup: { points: null, team: null, player: null, playerIndex: null },
                    bonus: { team1: 0, team2: 0, parts: [null, null, null] },
                    scores: [[], [], [], []]
                };
            }
            
            // Initialize bonus structure if it doesn't exist or is malformed
            if (!this.scorecard.cycles[this.currentCycle].bonus || !Array.isArray(this.scorecard.cycles[this.currentCycle].bonus.parts)) {
                this.scorecard.cycles[this.currentCycle].bonus = { 
                    team1: 0, 
                    team2: 0, 
                    parts: [null, null, null] 
                };
            }
            
            // Update the part score
            this.scorecard.cycles[this.currentCycle].bonus.parts[part - 1] = points;
            
            // Calculate total bonus points for the team
            const totalPoints = this.scorecard.cycles[this.currentCycle].bonus.parts
                .filter(p => p !== null)
                .reduce((sum, p) => sum + p, 0);
                
            this.scorecard.cycles[this.currentCycle].bonus[`team${teamNum}`] = totalPoints;
            
            // Update the UI
            this.updateScores();
            this.updateScorecardPreview();
            
            // Update button states
            const partContainer = button.closest('.bonus-part');
            if (partContainer) {
                // Remove active class from all buttons in this part
                partContainer.querySelectorAll('.bonus-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                
                // Add active class to clicked button
                button.classList.add('active');
                
                // Mark this part as completed
                partContainer.classList.add('completed');
                
                // Update the score display
                const scoreDisplay = partContainer.querySelector('.bonus-score');
                if (!scoreDisplay) {
                    const scoreElement = document.createElement('span');
                    scoreElement.className = 'ms-2 bonus-score';
                    scoreElement.textContent = `(${points} pts)`;
                    button.parentNode.appendChild(scoreElement);
                } else {
                    scoreDisplay.textContent = `(${points} pts)`;
                }
            }
            
        } catch (error) {
            console.error('Error in handleBonusPoints:', error);
        }
    },
    
    // Enable word clicking by resetting the current answerer
    enableWordClicking: function() {
        this.currentAnswerer = null;
        // The word click event listeners will be re-enabled automatically
        // when currentAnswerer is null
    },
    
    // Add markAnswer as an alias for handleAnswer for backward compatibility
    markAnswer: function(isCorrect) {
        if (!this.currentAnswerer) {
            console.error('No current answerer when marking answer');
            return;
        }
        console.log('markAnswer called with isCorrect:', isCorrect, 'for player:', this.currentAnswerer.playerName);
        return this.handleAnswer(isCorrect);
    },
    
    // Initialize the game when the DOM is loaded
    initGame: function() {
        console.log('[INIT] Initializing game...');
        
        // Expose gameState to global scope
        window.gameState = this;
        window.quizbowl = this;
        
        // Initialize flags
        this.isSkipping = false;
        
        // Initialize game state if needed
        if (typeof this.init === 'function') {
            this.init();
        }
        
        // Remove any existing event listeners from the skip button
        const skipBtn = document.getElementById('skipToNextCycleBtn');
        if (skipBtn) {
            // Clone and replace to remove all event listeners
            const newSkipBtn = skipBtn.cloneNode(true);
            skipBtn.parentNode.replaceChild(newSkipBtn, skipBtn);
            
            // Add single click handler
            newSkipBtn.onclick = (e) => {
                e.preventDefault();
                e.stopPropagation();
                this.skipToNextCycle();
                return false;
            };
        }

        // Set up next cycle button
        const nextCycleBtn = document.getElementById('nextCycleBtn');
        if (nextCycleBtn) {
            // Clone and replace to remove all event listeners
            const newNextCycleBtn = nextCycleBtn.cloneNode(true);
            nextCycleBtn.parentNode.replaceChild(newNextCycleBtn, nextCycleBtn);
            
            // Add single click handler
            newNextCycleBtn.onclick = (e) => {
                e.preventDefault();
                e.stopPropagation();
                console.log('Next cycle button clicked');
                this.nextCycle();
                return false;
            };
            
            // Enable the button
            newNextCycleBtn.disabled = false;
        }
    }
};

// Handle protest form submission
function submitProtest() {
    // Get form elements
    const gameInput = document.getElementById('protestGameId');
    const tournamentInput = document.getElementById('protestTournamentId');
    const cycleInput = document.getElementById('protestCycle');
    const messageInput = document.getElementById('protestMessage');
    
    // Debug: Log the actual DOM elements and their values
    console.log('Form elements:', {
        gameInput,
        tournamentInput,
        cycleInput,
        messageInput,
        gameId: gameInput?.value,
        tournamentId: tournamentInput?.value,
        cycleNumber: cycleInput?.value,
        message: messageInput?.value
    });
    
    // Get values with null checks
    const gameId = gameInput?.value || '';
    const tournamentId = tournamentInput?.value || '';
    const cycleNumber = cycleInput?.value || '';
    const message = messageInput?.value || '';
    
    // Debug: Log the form values
    console.log('Protest form values:', {
        gameId,
        tournamentId,
        cycleNumber,
        message: message ? 'present' : 'empty'
    });
    
    // Validate all required fields
    if (!gameId || !tournamentId || !cycleNumber) {
        console.error('Missing required fields:', { gameId, tournamentId, cycleNumber });
        alert('Error: Missing required game or tournament information.');
        return;
    }
    
    if (!message.trim()) {
        alert('Please enter a message describing the protest.');
        return;
    }
    
    const submitBtn = document.getElementById('submitProtestBtn');
    const originalText = submitBtn.innerHTML;
    submitBtn.disabled = true;
    submitBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Submitting...';
    
    // Prepare the request data with proper type conversion
    const requestData = {
        tournament_id: Number(tournamentId),
        game_id: Number(gameId),
        cycle_number: Number(cycleNumber),
        message: message.trim()
    };
    
    // Debug: Log the data types to ensure they're numbers
    console.log('Sending protest data:', {
        ...requestData,
        types: {
            tournament_id: typeof requestData.tournament_id,
            game_id: typeof requestData.game_id,
            cycle_number: typeof requestData.cycle_number,
            message: typeof requestData.message
        }
    });
    
    fetch('/api/protests', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': document.querySelector('meta[name="csrf-token"]').content
        },
        body: JSON.stringify(requestData)
    })
    .then(response => response.json())
    .then(data => {
        if (data.error) {
            throw new Error(data.error);
        }
        
        // Show success message
        const alertHtml = `
            <div class="alert alert-success alert-dismissible fade show" role="alert">
                <i class="bi bi-check-circle-fill me-2"></i>
                Your protest has been submitted successfully.
                <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
            </div>
        `;
        
        // Add alert to the page
        const alertDiv = document.createElement('div');
        alertDiv.innerHTML = alertHtml;
        document.querySelector('.container.mt-4').prepend(alertDiv);
        
        // Close the modal using Bootstrap 5's method
        const modalElement = document.getElementById('protestModal');
        const modal = bootstrap.Modal.getInstance(modalElement) || new bootstrap.Modal(modalElement);
        modal.hide();
        
        // Reset form
        document.getElementById('protestForm').reset();
        
        // Manually remove the modal backdrop if it remains
        const backdrops = document.getElementsByClassName('modal-backdrop');
        while(backdrops.length > 0) {
            backdrops[0].parentNode.removeChild(backdrops[0]);
        }
        // Remove the modal-open class from body
        document.body.classList.remove('modal-open');
        // Reset body padding if it was modified
        document.body.style.paddingRight = '';
    })
    .catch(error => {
        console.error('Error submitting protest:', error);
        alert('Failed to submit protest: ' + error.message);
    })
    .finally(() => {
        submitBtn.disabled = false;
        submitBtn.innerHTML = originalText;
    });
}

// Initialize the game when the DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    // Set up protest form submission
    document.getElementById('submitProtestBtn').addEventListener('click', submitProtest);
    
    // Set default cycle number to current cycle when modal is shown
    document.getElementById('protestModal').addEventListener('show.bs.modal', function () {
        if (typeof gameState !== 'undefined' && gameState.currentCycleIndex !== undefined) {
            document.getElementById('protestCycle').value = gameState.currentCycleIndex + 1;
        }
    });
    
    if (typeof gameState !== 'undefined') {
        gameState.initGame();
        
        // Add click event listener for download scorecard button
        const downloadBtn = document.getElementById('downloadScorecardBtn');
        if (downloadBtn) {
            downloadBtn.addEventListener('click', function(e) {
                e.preventDefault();
                if (typeof gameState.downloadScorecard === 'function') {
                    gameState.downloadScorecard();
                } else {
                    console.error('downloadScorecard function not found on gameState');
                    alert('Error: Download functionality not available');
                }
            });
        }

        // Add click event listener for TD call button
        const callTdBtn = document.getElementById('callTdBtn');
        if (callTdBtn) {
            callTdBtn.addEventListener('click', function(e) {
                e.preventDefault();
                if (confirm('Are you sure you want to call a Tournament Director to this room?')) {
                    sendAlert('td_call', 'TD assistance requested for this room');
                }
            });
        }

        // Add click event listener for emergency button
        const emergencyBtn = document.getElementById('emergencyBtn');
        if (emergencyBtn) {
            emergencyBtn.addEventListener('click', function(e) {
                e.preventDefault();
                if (confirm('EMERGENCY: This will immediately alert all staff. Only use for serious issues.\n\nAre you sure you want to trigger an emergency alert?')) {
                    sendAlert('emergency', 'EMERGENCY: Immediate assistance required in this room!');
                }
            });
        }

        // Function to send alert to server
        function sendAlert(alertType, message) {
            const gameId = gameState?.config?.game?.id;
            if (!gameId) {
                console.error('No game ID available');
                alert('Error: Could not determine game ID');
                return;
            }

            fetch('/api/alerts', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': document.querySelector('meta[name="csrf-token"]')?.content || ''
                },
                body: JSON.stringify({
                    game_id: gameId,
                    level: alertType,
                    message: message,
                    room: `Room ${gameId}`
                })
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(data => {
                alert('Alert sent successfully! Help is on the way.');
                console.log('Alert created:', data);
            })
            .catch(error => {
                console.error('Error sending alert:', error);
                alert('Error sending alert. Please try again or find a staff member.');
            });
        }
    }
});

// Close the IIFE and the script tag
})();
</script>
{% endblock %}